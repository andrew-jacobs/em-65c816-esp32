
Portable 65xx Assembler [19.05]

                             ;===============================================================================
                             ;  _____ __  __        __  ____   ____ ___  _  __
                             ; | ____|  \/  |      / /_| ___| / ___( _ )/ |/ /_
                             ; |  _| | |\/| |_____| '_ \___ \| |   / _ \| | '_ \
                             ; | |___| |  | |_____| (_) |__) | |__| (_) | | (_) |
                             ; |_____|_|__|_|___ __\___/____/ \____\___/|_|\___/
                             ; | ____/ ___||  _ \___ /___ \
                             ; |  _| \___ \| |_) ||_ \ __) |
                             ; | |___ ___) |  __/___) / __/
                             ; |_____|____/|_|  |____/_____|
                             ;
                             ; Boot ROM, Monitor & Operating System
                             ;-------------------------------------------------------------------------------
                             ; Copyright (C),2019 Andrew John Jacobs
                             ; All rights reserved.
                             ;
                             ; This work is made available under the terms of the Creative Commons
                             ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
                             ; following URL to see the details.
                             ;
                             ; http://creativecommons.org/licenses/by-nc-sa/4.0/
                             ;
                             ;===============================================================================
                             ; Notes:
                             ;
                             ; This source file builds both the boot ($00:f000-ffff) and rom0 ($04:0000-ffff)
                             ; images.
                             ;
                             ; The following table describes the memory map of the target system.
                             ;
                             ; +---------+----+-------------------------------
                             ; | 00:0000 | RW | OS Variables & Stack
                             ; +---------+----+-------------------------------
                             ; | 00:1000 | RW | Task Zero Pages & Stack
                             ; |---------+----+-------------------------------
                             ; | 00:2000 | RW | Other tasks areas
                             ; |         |    |
                             ; |         |    |
                             ; +---------+----+-------------------------------
                             ; | 00:ee00 | RW | Monitor Workspace - Can be overwritten
                             ; +---------+----+-------------------------------
                             ; | 00:ef00 | RW | I/O Workspace (Timer & UART Buffers)
                             ; +---------+----+-------------------------------
                             ; | 00:f000 | RO | OS Boot ROM & Interrupt Handlers
                             ; | 00:ffe0 |    | Native Mode Vectors
                             ; | 00:fff0 |    | Emulation Mode Vectors
                             ; +---------+----+-------------------------------
                             ; | 01:0000 | RW | Video
                             ; +---------+----+-------------------------------
                             ; | 02:0000 | RW | SRAM
                             ; | 03:0000 |    |
                             ; +---------+----+-------------------------------
                             ; | 04:0000 | RO | OS Code + Monitor
                             ; | 05:0000 |    | ROM1 (Spare)

Portable 65xx Assembler [19.05]

                             ; | 06:0000 |    | ROM2 (Spare)
                             ; | 07:0000 |    | ROM3 (Spare)
                             ; +---------+----+-------------------------------
                             ;
                             ;
                             ;-------------------------------------------------------------------------------

                                             .65816

                                             .include "../w65c816.inc"
                             ;==============================================================================
                             ; __        ____  ____   ____ ___  _  __
                             ; \ \      / / /_| ___| / ___( _ )/ |/ /_
                             ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \
                             ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
                             ;    \_/\_/  \___/____/ \____\___/|_|\___/
                             ;
                             ; Western Design Center W65C816 device definitions
                             ;------------------------------------------------------------------------------
                             ; Copyright (C)2015-2019 HandCoded Software Ltd.
                             ; All rights reserved.
                             ;
                             ; This work is made available under the terms of the Creative Commons
                             ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
                             ; following URL to see the details.
                             ;
                             ; http://creativecommons.org/licenses/by-nc-sa/4.0/
                             ;
                             ;===============================================================================
                             ; Notes:
                             ;
                             ; Various macros and definitions for the W65C816 microprocessor.
                             ;
                             ;===============================================================================
                             ; Revision History:
                             ;
                             ; 2015-12-18 AJ Initial version
                             ;-------------------------------------------------------------------------------

                             ;==============================================================================
                             ; Status Register Bits
                             ;------------------------------------------------------------------------------

         00000080          = N_FLAG          .equ    1<<7
         00000040          = V_FLAG          .equ    1<<6
         00000020          = M_FLAG          .equ    1<<5
         00000010          = X_FLAG          .equ    1<<4
         00000010          = B_FLAG          .equ    1<<4
         00000008          = D_FLAG          .equ    1<<3
         00000004          = I_FLAG          .equ    1<<2
         00000002          = Z_FLAG          .equ    1<<1
         00000001          = C_FLAG          .equ    1<<0

                             ;==============================================================================

Portable 65xx Assembler [19.05]

                             ; Macros
                             ;------------------------------------------------------------------------------

                             ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
                             ; is fixed at $0100-$01ff.

                             emulate         .macro
                                             sec
                                             xce
                                             .endm

                             ; Puts the processor in native mode. The size of the memory and index register
                             ; operations is not controlled by the M & X bits in the status register.

                             native          .macro
                                             clc
                                             xce
                                             .endm

                             ; Resets the M bit making the accumulator and memory accesses 16-bits wide.

                             long_a          .macro
                                             rep     #M_FLAG
                                             .longa  on
                                             .endm

                             ; Resets the X bit making the index registers 16-bits wide

                             long_i          .macro
                                             rep     #X_FLAG
                                             .longi  on
                                             .endm

                             ; Resets the M and X bits making the accumulator, memory accesses and index
                             ; registers 16-bits wide.

                             long_ai         .macro
                                             rep     #M_FLAG|X_FLAG
                                             .longa  on
                                             .longi  on
                                             .endm

                             ; Sets the M bit making the accumulator and memory accesses 8-bits wide.

                             short_a         .macro
                                             sep     #M_FLAG
                                             .longa  off
                                             .endm

                             ; Sets the X bit making the index registers 8-bits wide.

                             short_i         .macro
                                             sep     #X_FLAG
                                             .longi  off

Portable 65xx Assembler [19.05]

                                             .endm

                             ; Sets the M & X bits making the accumulator, memory accesses and index
                             ; registers 8-bits wide.

                             short_ai        .macro
                                             sep     #M_FLAG|X_FLAG
                                             .longa  off
                                             .longi  off
                                             .endm
                                             .include "../signature.inc"
                             ;===============================================================================
                             ;  _____ __  __        __  ____   ____ ___  _  __
                             ; | ____|  \/  |      / /_| ___| / ___( _ )/ |/ /_
                             ; |  _| | |\/| |_____| '_ \___ \| |   / _ \| | '_ \
                             ; | |___| |  | |_____| (_) |__) | |__| (_) | | (_) |
                             ; |_____|_|__|_|___ __\___/____/ \____\___/|_|\___/
                             ; | ____/ ___||  _ \___ /___ \
                             ; |  _| \___ \| |_) ||_ \ __) |
                             ; | |___ ___) |  __/___) / __/
                             ; |_____|____/|_|  |____/_____|
                             ;
                             ;-------------------------------------------------------------------------------
                             ; Copyright (C)2018-2019 Andrew John Jacobs
                             ; All rights reserved.
                             ;
                             ; This work is made available under the terms of the Creative Commons
                             ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
                             ; following URL to see the details.
                             ;
                             ; http://creativecommons.org/licenses/by-nc-sa/4.0/
                             ;===============================================================================
                             ;
                             ; Notes:
                             ;
                             ;-------------------------------------------------------------------------------

                             ;===============================================================================
                             ; WDM Signature Bytes
                             ;-------------------------------------------------------------------------------

         00000000          = WDM_IER_RD      .equ    $00
         00000001          = WDM_IER_WR      .equ    $01
         00000002          = WDM_IER_SET     .equ    $02
         00000003          = WDM_IER_CLR     .equ    $03

         00000004          = WDM_IFR_RD      .equ    $04
         00000005          = WDM_IFR_WR      .equ    $05
         00000006          = WDM_IFR_SET     .equ    $06
         00000007          = WDM_IFR_CLR     .equ    $07

         00000008          = WDM_IFLAGS      .equ    $08

         00000010          = WDM_U1TX        .equ    $10

Portable 65xx Assembler [19.05]

         00000011          = WDM_U1RX        .equ    $11

                             ;===============================================================================
                             ; IER/IFR Bits
                             ;-------------------------------------------------------------------------------

         00000001          = INT_CLK         .equ    $0001
         00000002          = INT_U1RX        .equ    $0002
         00000004          = INT_U1TX        .equ    $0004

                             ;===============================================================================
                             ; Macros
                             ;-------------------------------------------------------------------------------

                             MNEM            .macro
                                             .word   ((\0-'@')<<10)|((\1-'@')<<5)|((\2-'@')<<0)
                                             .endm

                             ;===============================================================================
                             ; Constants
                             ;-------------------------------------------------------------------------------

                             ; ASCII Control characters

         00000007          = BEL             .equ    $07
         00000008          = BS              .equ    $08
         0000000A          = LF              .equ    $0a
         0000000D          = CR              .equ    $0d
         0000001B          = ESC             .equ    $1b
         0000007F          = DEL             .equ    $7f

                             ;-------------------------------------------------------------------------------

         0000EE00          = MON_PAGE        .equ    $ee00                   ; Monitors private data page
         0000EF00          = IO_PAGE         .equ    $ef00                   ; I/O private data page

         00000040          = UART_BUFSIZ     .equ    64                      ; UART buffer size

                                             .page

Portable 65xx Assembler [19.05]

                             ;===============================================================================
                             ; Private I/O Data Area
                             ;-------------------------------------------------------------------------------

                                             .bss
                                             .org    IO_PAGE

00:EF00  00                : TX_HEAD:        .space  1                       ; Transmit buffer head and tail
00:EF01  00                : TX_TAIL:        .space  1                       ; .. indices
00:EF02  00                : RX_HEAD:        .space  1                       ; Receive buffer head and tail
00:EF03  00                : RX_TAIL:        .space  1                       ; .. indices

00:EF04  00000000          : TICK:           .space  4                       ; Clock tick counter

00:EF08  0000000000000000> : TX_DATA:        .space  UART_BUFSIZ             ; Uart transmit buffer
00:EF48  0000000000000000> : RX_DATA:        .space  UART_BUFSIZ             ; Uart receive buffer

                                             .if     $ > $efff
                                             .error  "Exceeded I/O Page size"
                                             .endif

                             ;===============================================================================
                             ; Operating System Entry Points
                             ;-------------------------------------------------------------------------------
                                             .code
                                             .org    $f000

00:F000  826C00            :                 brl     Uart1Tx                 ; JSL $f000 - UART1 Transmit
00:F003  829700            :                 brl     Uart1Rx                 ; JSL $f003 - UART1 Receive
00:F006  82B400            :                 brl     Uart1RxCount            ; JSL $f006 - UART1 RX Count

                             ;===============================================================================
                             ; API Entry
                             ;-------------------------------------------------------------------------------

                             COPE:
00:F009  40                :                 rti
                             COPN:
00:F00A  40                :                 rti

                             ;===============================================================================
                             ; Power On Reset
                             ;-------------------------------------------------------------------------------

                                             .longa  off
                                             .longi  off
                             RESET:
00:F00B  78                :                 sei                             ; Ensure no interrupts
00:F00C  D8                :                 cld

00:F00D  A208              :                 ldx     #8                      ; Clear FIFO indexes and timer
                                             repeat
00:F00F  CA                :                  dex
00:F010  9E00EF            :                  stz    IO_PAGE,x

Portable 65xx Assembler [19.05]

00:F013  D0FA              :                 until eq

00:F015  18                :                 clc                             ; Switch to native mode
00:F016  FB                :                 xce

                                             long_ai
00:F017  C230              +                 rep     #M_FLAG|X_FLAG
                           +                 .longa  on
                           +                 .longi  on
00:F019  A2FF0F            :                 ldx     #$0fff                  ; Set O/S stack
00:F01C  9A                :                 txs
00:F01D  A90300            :                 lda     #INT_CLK|INT_U1RX       ; Enable clock and receive
00:F020  4201              :                 wdm     #WDM_IER_WR
00:F022  58                :                 cli                             ; Allow interrupts

                                             short_a                         ; Display a boot message
00:F023  E220              +                 sep     #M_FLAG
                           +                 .longa  off
00:F025  A237F0            :                 ldx     #BOOT_MESSAGE
                                             repeat
00:F028  BD0000            :                  lda    !0,x
00:F02B  F007              :                  break eq
00:F02D  226FF000          :                  jsl    Uart1Tx
00:F031  E8                :                  inx
00:F032  80F4              :                 forever

00:F034  0000              :                 brk     #0                      ; Then enter the monitor
00:F036  DB                :                 stp

00:F037  0D0A454D2D363543> : BOOT_MESSAGE:   .byte   CR,LF,"EM-65C816-ESP32 [19.06]"
00:F050  0D0A284329323031> :                 .byte   CR,LF,"(C)2018-2019 Andrew Jacobs"
00:F06C  0D0A00            :                 .byte   CR,LF,0

                             ;===============================================================================
                             ; Uart1 I/O
                             ;-------------------------------------------------------------------------------

                             ; Transmit the character in A via UART1 regardless of the state of the processor
                             ; and preserve all the registers. If the buffer is full then wait for it to
                             ; drain so there is at least one free space.

                                             .longa  ?
                                             .longi  ?
                             Uart1Tx:
00:F06F  08                :                 php                             ; Save MX bits
00:F070  DA                :                 phx                             ; .. and X
                                             short_a                         ; Make A/M 8-bits
00:F071  E220              +                 sep     #M_FLAG
                           +                 .longa  off
00:F073  48                :                 pha                             ; Sava A & B
00:F074  EB                :                 xba
00:F075  48                :                 pha
00:F076  AF01EF00          :                 lda     >TX_TAIL                ; Insert data at end of queue
00:F07A  AA                :                 tax

Portable 65xx Assembler [19.05]

00:F07B  EB                :                 xba
00:F07C  9F08EF00          :                 sta     >TX_DATA,x
00:F080  E8                :                 inx                             ; Bump tail index
00:F081  8A                :                 txa
00:F082  293F              :                 and     #UART_BUFSIZ-1          ; .. and wrap
                                             repeat
00:F084  CF00EF00          :                  cmp    >TX_HEAD                ; If buffer is completely full
00:F088  F0FA              :                 until ne                        ; .. wait for it to drain
00:F08A  78                :                 sei                             ; Update the tail
00:F08B  8F01EF00          :                 sta     >TX_TAIL
00:F08F  A900              :                 lda     #>INT_U1TX              ; Ensure TX interrupt enabled
00:F091  EB                :                 xba
00:F092  A904              :                 lda     #<INT_U1TX
00:F094  4202              :                 wdm     #WDM_IER_SET
00:F096  58                :                 cli
00:F097  68                :                 pla                             ; Restore B & A
00:F098  EB                :                 xba
00:F099  68                :                 pla
00:F09A  FA                :                 plx                             ; Restore X
00:F09B  28                :                 plp                             ; .. and MX flags
00:F09C  6B                :                 rtl                             ; Done

                             ; Receive a character from UART1 into A regardless of the state of rhe processor
                             ; preserving all other registers. If the buffer is empty then wait for some data
                             ; to arrive.

                                             .longa  ?
                                             .longi  ?
                             Uart1Rx:
00:F09D  08                :                 php                             ; Save MX bits & x
00:F09E  DA                :                 phx
                                             short_a                         ; Make A/M 8-bit
00:F09F  E220              +                 sep     #M_FLAG
                           +                 .longa  off
                                             repeat
00:F0A1  AF02EF00          :                  lda    >RX_HEAD                ; Wait while buffer is empty
00:F0A5  CF03EF00          :                  cmp    >RX_TAIL
00:F0A9  F0F6              :                 until ne
00:F0AB  AA                :                 tax
00:F0AC  BF48EF00          :                 lda     >RX_DATA,x
00:F0B0  48                :                 pha
00:F0B1  E8                :                 inx                             ; Bump head index
00:F0B2  8A                :                 txa
00:F0B3  293F              :                 and     #UART_BUFSIZ-1          ; .. and wrap
00:F0B5  8F02EF00          :                 sta     >RX_HEAD                ; Then update head
00:F0B9  68                :                 pla
00:F0BA  FA                :                 plx                             ; Restore X and flags
00:F0BB  28                :                 plp
00:F0BC  6B                :                 rtl

                             ; Return the number of characters in the RX buffer in A.

                                             .longa  ?
                                             .longi  ?

Portable 65xx Assembler [19.05]

                             Uart1RxCount:
00:F0BD  08                :                 php                             ; Save MX bits
                                             short_a                         ; Make A/M 8-bit
00:F0BE  E220              +                 sep     #M_FLAG
                           +                 .longa  off
00:F0C0  38                :                 sec
00:F0C1  AF03EF00          :                 lda     >RX_TAIL                ; Work out index difference
00:F0C5  EF02EF00          :                 sbc     >RX_HEAD
00:F0C9  1002              :                 if mi
00:F0CB  6940              :                  adc    #UART_BUFSIZ            ; Correct if negative
                                             endif
00:F0CD  28                :                 plp                             ; Restore callers state
00:F0CE  6B                :                 rtl

                             ;===============================================================================
                             ; Interrupt Handlers
                             ;-------------------------------------------------------------------------------

                             ; In emulation mode the interrupt handler must differentiate between IRQ and
                             ; BRK.

                                             .longa  off
                                             .longi  off
                             IRQBRK:
00:F0CF  48                :                 pha                             ; Save users A
00:F0D0  A302              :                 lda     2,s                     ; Recover P
00:F0D2  2910              :                 and     #$10
00:F0D4  F005              :                 if ne
00:F0D6  68                :                  pla                            ; Restores users A
00:F0D7  5C000004          : BRKN:            jml    Monitor                 ; Enter the monitor
                                             endif

00:F0DB  EB                :                 xba                             ; Save users B
00:F0DC  48                :                 pha
00:F0DD  DA                :                 phx                             ; .. and X

00:F0DE  20F4F0            :                 jsr     IRQHandler              ; Do common processing

00:F0E1  FA                :                 plx                             ; Restore users X,
00:F0E2  68                :                 pla                             ; .. B, and A
00:F0E3  EB                :                 xba
00:F0E4  68                :                 pla
00:F0E5  40                :                 rti                             ; .. and continue

                             ;-------------------------------------------------------------------------------

                                             .longa  ?
                                             .longi  ?
                             IRQN:
                                             long_ai                         ; Then go full 16-bit
00:F0E6  C230              +                 rep     #M_FLAG|X_FLAG
                           +                 .longa  on
                           +                 .longi  on
00:F0E8  48                :                 pha                             ; .. and save C & X

Portable 65xx Assembler [19.05]

00:F0E9  DA                :                 phx
                                             short_a                         ; Then make A/M 8-bits
00:F0EA  E220              +                 sep     #M_FLAG
                           +                 .longa  off

00:F0EC  20F4F0            :                 jsr     IRQHandler              ; Do common processing

                                             long_a                          ; Restore users X & C
00:F0EF  C220              +                 rep     #M_FLAG
                           +                 .longa  on
00:F0F1  FA                :                 plx
00:F0F2  68                :                 pla
00:F0F3  40                :                 rti                             ; .. and continue

                             ;-------------------------------------------------------------------------------

                             ; This is the main IRQ handler used in both native and emulation mode. The size
                             ; of A/M access is 8-bits but X/Y are undefined. X is used to index into buffer
                             ; areas but is always loaded/stored via A.

                                             .longa  off
                                             .longi  ?
                             IRQHandler:
00:F0F4  8B                :                 phb                             ; Save users data bank
00:F0F5  4B                :                 phk                             ; And switch to bank $00
00:F0F6  AB                :                 plb

00:F0F7  4208              :                 wdm     #WDM_IFLAGS             ; Fetch interrupt flags
00:F0F9  48                :                 pha                             ; .. and save some copies
00:F0FA  48                :                 pha

00:F0FB  2901              :                 and     #INT_CLK                ; Is this a timer interrupt?
00:F0FD  F014              :                 if ne
00:F0FF  4207              :                  wdm    #WDM_IFR_CLR            ; Yes, clear it

00:F101  EE04EF            :                  inc    TICK+0                  ; Bump the tick counter
00:F104  D00D              :                  if eq
00:F106  EE05EF            :                   inc   TICK+1
00:F109  D008              :                   if eq
00:F10B  EE06EF            :                    inc  TICK+2
00:F10E  D003              :                    if eq
00:F110  EE07EF            :                     inc TICK+3
                                                endif
                                               endif
                                              endif
                                             endif

00:F113  68                :                 pla                             ; Check for received data
00:F114  2902              :                 and     #INT_U1RX
00:F116  F015              :                 if ne
00:F118  AD03EF            :                  lda    RX_TAIL                 ; Save at tail of RX buffer
00:F11B  AA                :                  tax
00:F11C  4211              :                  wdm    #WDM_U1RX
00:F11E  9D48EF            :                  sta    RX_DATA,x

Portable 65xx Assembler [19.05]

00:F121  E8                :                  inx                            ; Bump the index
00:F122  8A                :                  txa
00:F123  293F              :                  and    #UART_BUFSIZ-1          ; .. and wrap
00:F125  CD02EF            :                  cmp    RX_HEAD                 ; Is RX buffer complete full?
00:F128  F003              :                  if ne
00:F12A  8D03EF            :                   sta   RX_TAIL                 ; No, save new tail
                                              endif
                                             endif

00:F12D  68                :                 pla                             ; Ready to transmit?
00:F12E  2904              :                 and     #INT_U1TX
00:F130  F019              :                 if ne
00:F132  AD00EF            :                  lda    TX_HEAD                 ; Fetch next character to send
00:F135  AA                :                  tax
00:F136  BD08EF            :                  lda    TX_DATA,x
00:F139  4210              :                  wdm    #WDM_U1TX               ; .. and transmit it
00:F13B  E8                :                  inx                            ; Bump the index
00:F13C  8A                :                  txa
00:F13D  293F              :                  and    #UART_BUFSIZ-1          ; .. and wrap
00:F13F  8D00EF            :                  sta    TX_HEAD                 ; Save updated head
00:F142  CD01EF            :                  cmp    TX_TAIL                 ; Is the buffer now empty?
00:F145  D004              :                  if eq
00:F147  A904              :                   lda   #INT_U1TX
00:F149  4203              :                   wdm   #WDM_IER_CLR            ; Yes disable TX interrupt
                                              endif
                                             endif

00:F14B  AB                :                 plb
00:F14C  60                :                 rts                             ; Done

                             ;===============================================================================
                             ; Unused Vector Trap
                             ;-------------------------------------------------------------------------------

                             ; If any undefined vectors are invoked execution will end up here doing in an
                             ; infinite loop.

                             UnusedVector
00:F14D  DB                :                 stp
00:F14E  80FE              :                 bra     $

                             ;===============================================================================
                             ; Vectors
                             ;-------------------------------------------------------------------------------

                             ; Native Mode Vectors

                                             .org    $ffe0

00:FFE0  00000000          :                 .space  4                       ; Reserved
00:FFE4  0AF0              :                 .word   COPN                    ; $FFE4 - COP(816)
00:FFE6  D7F0              :                 .word   BRKN                    ; $FFE6 - BRK(816)
00:FFE8  4DF1              :                 .word   UnusedVector            ; $FFE8 - ABORT(816)
00:FFEA  4DF1              :                 .word   UnusedVector            ; $FFEA - NMI(816)

Portable 65xx Assembler [19.05]

00:FFEC  0000              :                 .space  2                       ; Reserved
00:FFEE  E6F0              :                 .word   IRQN                    ; $FFEE - IRQ(816)

                             ; Emulation Mode Vectors

                                             .org    $fff0
00:FFF0  00000000          :                 .space  4
00:FFF4  4DF1              :                 .word   UnusedVector            ; $FFF4 - COP(C02)
00:FFF6  0000              :                 .space  2                       ; $Reserved
00:FFF8  4DF1              :                 .word   UnusedVector            ; $FFF8 - ABORT(C02)
00:FFFA  4DF1              :                 .word   UnusedVector            ; $FFFA - NMI(C02)
00:FFFC  0BF0              :                 .word   RESET                   ; $FFFC - RESET(C02)
00:FFFE  CFF0              :                 .word   IRQBRK                  ; $FFFE - IRQBRK(C02)

                                             .page

Portable 65xx Assembler [19.05]

                             ;===============================================================================
                             ; Video RAM
                             ;-------------------------------------------------------------------------------

                             ; Bank $01 is reserved for video data. The intended display will be 800x600
                             ; monochrome.

         00000320          = SVGA_WIDTH      .equ    800
         00000258          = SVGA_HEIGHT     .equ    600
         00000008          = PIXELS_PER_BYTE .equ    8
         00000064          = BYTES_PER_LINE  .equ    SVGA_WIDTH / PIXELS_PER_BYTE

                                             .bss
                                             .org    $010000

01:0000  0000000000000000> : VLINES          .space  SVGA_HEIGHT * 2         ; Scan line pointers

01:04B0  0000000000000000> : VDATA           .space  SVGA_HEIGHT * BYTES_PER_LINE
                             VEND            .space  0

                                             .page

Portable 65xx Assembler [19.05]

                             ;===============================================================================
                             ; Operating System
                             ;-------------------------------------------------------------------------------

                                             .code
                                             .org    $040000

                             ; This is the target area for my operating system ROM.

                                             .page

Portable 65xx Assembler [19.05]

                             ;===============================================================================
                             ; Monitor
                             ;-------------------------------------------------------------------------------
                             ; This is a simple monitor based on my SXB-Hacker code. It allows access to the
                             ; emulated address space and the ability to download, inspect, change and run
                             ; machine language programs. It uses the interrupt driven I/O routines in the
                             ; boot ROM accessed by JSLs to $F000 and $F003.
                             ;
                             ; If the monitor is not in use workspace page is never accessed and could be
                             ; used by another application.

                             ;===============================================================================
                             ; Opcodes & Addressing Modes
                             ;-------------------------------------------------------------------------------

         00000000          = OP_ADC          .equ    0<<1
         00000002          = OP_AND          .equ    1<<1
         00000004          = OP_ASL          .equ    2<<1
         00000006          = OP_BCC          .equ    3<<1
         00000008          = OP_BCS          .equ    4<<1
         0000000A          = OP_BEQ          .equ    5<<1
         0000000C          = OP_BIT          .equ    6<<1
         0000000E          = OP_BMI          .equ    7<<1
         00000010          = OP_BNE          .equ    8<<1
         00000012          = OP_BPL          .equ    9<<1
         00000014          = OP_BRA          .equ    10<<1
         00000016          = OP_BRK          .equ    11<<1
         00000018          = OP_BRL          .equ    12<<1
         0000001A          = OP_BVC          .equ    13<<1
         0000001C          = OP_BVS          .equ    14<<1
         0000001E          = OP_CLC          .equ    15<<1
         00000020          = OP_CLD          .equ    16<<1
         00000022          = OP_CLI          .equ    17<<1
         00000024          = OP_CLV          .equ    18<<1
         00000026          = OP_CMP          .equ    19<<1
         00000028          = OP_COP          .equ    20<<1
         0000002A          = OP_CPX          .equ    21<<1
         0000002C          = OP_CPY          .equ    22<<1
         0000002E          = OP_DEC          .equ    23<<1
         00000030          = OP_DEX          .equ    24<<1
         00000032          = OP_DEY          .equ    25<<1
         00000034          = OP_EOR          .equ    26<<1
         00000036          = OP_INC          .equ    27<<1
         00000038          = OP_INX          .equ    28<<1
         0000003A          = OP_INY          .equ    29<<1
         0000003C          = OP_JML          .equ    30<<1
         0000003E          = OP_JMP          .equ    31<<1
         00000040          = OP_JSL          .equ    32<<1
         00000042          = OP_JSR          .equ    33<<1
         00000044          = OP_LDA          .equ    34<<1
         00000046          = OP_LDX          .equ    35<<1
         00000048          = OP_LDY          .equ    36<<1
         0000004A          = OP_LSR          .equ    37<<1
         0000004C          = OP_MVN          .equ    38<<1

Portable 65xx Assembler [19.05]

         0000004E          = OP_MVP          .equ    39<<1
         00000050          = OP_NOP          .equ    40<<1
         00000052          = OP_ORA          .equ    41<<1
         00000054          = OP_PEA          .equ    42<<1
         00000056          = OP_PEI          .equ    43<<1
         00000058          = OP_PER          .equ    44<<1
         0000005A          = OP_PHA          .equ    45<<1
         0000005C          = OP_PHB          .equ    46<<1
         0000005E          = OP_PHD          .equ    47<<1
         00000060          = OP_PHK          .equ    48<<1
         00000062          = OP_PHP          .equ    49<<1
         00000064          = OP_PHX          .equ    50<<1
         00000066          = OP_PHY          .equ    51<<1
         00000068          = OP_PLA          .equ    52<<1
         0000006A          = OP_PLB          .equ    53<<1
         0000006C          = OP_PLD          .equ    54<<1
         0000006E          = OP_PLP          .equ    55<<1
         00000070          = OP_PLX          .equ    56<<1
         00000072          = OP_PLY          .equ    57<<1
         00000074          = OP_REP          .equ    58<<1
         00000076          = OP_ROL          .equ    59<<1
         00000078          = OP_ROR          .equ    60<<1
         0000007A          = OP_RTI          .equ    61<<1
         0000007C          = OP_RTL          .equ    62<<1
         0000007E          = OP_RTS          .equ    63<<1
         00000080          = OP_SBC          .equ    64<<1
         00000082          = OP_SEC          .equ    65<<1
         00000084          = OP_SED          .equ    66<<1
         00000086          = OP_SEI          .equ    67<<1
         00000088          = OP_SEP          .equ    68<<1
         0000008A          = OP_STA          .equ    69<<1
         0000008C          = OP_STP          .equ    70<<1
         0000008E          = OP_STX          .equ    71<<1
         00000090          = OP_STY          .equ    72<<1
         00000092          = OP_STZ          .equ    73<<1
         00000094          = OP_TAX          .equ    74<<1
         00000096          = OP_TAY          .equ    75<<1
         00000098          = OP_TCD          .equ    76<<1
         0000009A          = OP_TCS          .equ    77<<1
         0000009C          = OP_TDC          .equ    78<<1
         0000009E          = OP_TRB          .equ    79<<1
         000000A0          = OP_TSB          .equ    80<<1
         000000A2          = OP_TSC          .equ    81<<1
         000000A4          = OP_TSX          .equ    82<<1
         000000A6          = OP_TXA          .equ    83<<1
         000000A8          = OP_TXS          .equ    84<<1
         000000AA          = OP_TXY          .equ    85<<1
         000000AC          = OP_TYA          .equ    86<<1
         000000AE          = OP_TYX          .equ    87<<1
         000000B0          = OP_WAI          .equ    88<<1
         000000B2          = OP_WDM          .equ    89<<1
         000000B4          = OP_XBA          .equ    90<<1
         000000B6          = OP_XCE          .equ    91<<1


Portable 65xx Assembler [19.05]

         00000000          = MD_ABS          .equ    0<<1                    ; a
         00000002          = MD_ACC          .equ    1<<1                    ; A
         00000004          = MD_ABX          .equ    2<<1                    ; a,x
         00000006          = MD_ABY          .equ    3<<1                    ; a,y
         00000008          = MD_ALG          .equ    4<<1                    ; al
         0000000A          = MD_ALX          .equ    5<<1                    ; al,x
         0000000C          = MD_AIN          .equ    6<<1                    ; (a)
         0000000E          = MD_AIX          .equ    7<<1                    ; (a,x)
         00000010          = MD_DPG          .equ    8<<1                    ; d
         00000012          = MD_STK          .equ    9<<1                    ; d,s
         00000014          = MD_DPX          .equ    10<<1                   ; d,x
         00000016          = MD_DPY          .equ    11<<1                   ; d,x
         00000018          = MD_DIN          .equ    12<<1                   ; (d)
         0000001A          = MD_DLI          .equ    13<<1                   ; [d]
         0000001C          = MD_SKY          .equ    14<<1                   ; (d,s),y
         0000001E          = MD_DIX          .equ    15<<1                   ; (d,x)
         00000020          = MD_DIY          .equ    16<<1                   ; (d),y
         00000022          = MD_DLY          .equ    17<<1                   ; [d],y
         00000024          = MD_IMP          .equ    18<<1                   ;
         00000026          = MD_REL          .equ    19<<1                   ; r
         00000028          = MD_RLG          .equ    20<<1                   ; rl
         0000002A          = MD_MOV          .equ    21<<1                   ; xyc
         0000002C          = MD_IMM          .equ    22<<1                   ; # (A or M)
         0000002E          = MD_INT          .equ    23<<1                   ; # (BRK/COP/WDM)
         00000030          = MD_IMX          .equ    24<<1                   ; # (X or Y)

                             ;===============================================================================
                             ; Private Data Area
                             ;-------------------------------------------------------------------------------

                                             .bss
                                             .org    MON_PAGE

                             ; User Registers

00:EE00  00                : REG_E           .space  1                       ; In bit 7
00:EE01  00                : REG_P           .space  1
00:EE02  0000              : REG_C           .space  2
00:EE04  0000              : REG_X           .space  2
00:EE06  0000              : REG_Y           .space  2
00:EE08  0000              : REG_SP          .space  2
00:EE0A  0000              : REG_DP          .space  2
00:EE0C  0000              : REG_PC          .space  2
00:EE0E  00                : REG_PBR         .space  1
00:EE0F  00                : REG_DBR         .space  1

00:EE10  00                : CMD_LEN         .space  1                       ; Command buffer length
00:EE11  000000            : VALUE           .space  3                       ; Value parsing area
00:EE14  00                : DEFAULT         .space  1                       ; Default bank (DBR on entry)
00:EE15  00                : FLAGS           .space  1                       ; Flag bits during disassembly

00:EE16  000000            : ADDR_S          .space  3                       ; Memory start address
00:EE19  000000            : ADDR_E          .space  3                       ; Memory end adddress


Portable 65xx Assembler [19.05]

00:EE1C  0000000000000000> :                 .align  128                     ; Gap used for stack
00:EE80  0000000000000000> : CMD_BUF         .space  128                     ; Command buffer

                             ;-------------------------------------------------------------------------------

                             ; The entry point is called from the boot ROM when a BRK instruction is executed
                             ; in either emulation or native mode.

                                             .code
                                             .longa  ?
                                             .longi  ?
                                             .dpage  REG_E
                             Monitor:
                                             short_a                         ; Ensure A/M 8-bits
04:0000  E220              +                 sep     #M_FLAG
                           +                 .longa  off
04:0002  0B                :                 phd                             ; Push users DP
04:0003  F400EE            :                 pea     #REG_E                  ; Move to monitor's direct page
04:0006  2B                :                 pld
04:0007  8502              :                 sta     REG_C+0                 ; Save C
04:0009  EB                :                 xba
04:000A  8503              :                 sta     REG_C+1
04:000C  68                :                 pla                             ; Save DP
04:000D  850A              :                 sta     REG_DP+0
04:000F  68                :                 pla
04:0010  850B              :                 sta     REG_DP+1
04:0012  68                :                 pla                             ; Save P
04:0013  8501              :                 sta     REG_P
04:0015  38                :                 sec                             ; Save PC (adjusting for BRK)
04:0016  68                :                 pla
04:0017  E902              :                 sbc     #2
04:0019  850C              :                 sta     REG_PC+0
04:001B  68                :                 pla
04:001C  E900              :                 sbc     #0
04:001E  850D              :                 sta     REG_PC+1
04:0020  18                :                 clc                             ; Switch to native mode
04:0021  FB                :                 xce
04:0022  640E              :                 stz     REG_PBR
04:0024  B003              :                 if cc
04:0026  68                :                  pla
04:0027  850E              :                  sta    REG_PBR                 ; Save PBR
                                             endif
04:0029  6600              :                 ror     REG_E                   ; Save E
04:002B  8B                :                 phb                             ; Save DBR
04:002C  68                :                 pla
04:002D  850F              :                 sta     REG_DBR
04:002F  8514              :                 sta     DEFAULT
                                             long_i
04:0031  C210              +                 rep     #X_FLAG
                           +                 .longi  on
04:0033  8604              :                 stx     REG_X                   ; Save X
04:0035  8406              :                 sty     REG_Y                   ; Save Y
04:0037  BA                :                 tsx
04:0038  8608              :                 stx     REG_SP                  ; Save SP

Portable 65xx Assembler [19.05]

04:003A  A27FEE            :                 ldx     #CMD_BUF-1              ; .. then load ours
04:003D  9A                :                 txs

04:003E  4B                :                 phk                             ; Set DBR to this bank (to
04:003F  AB                :                 plb                             ; .. access data and strings)
04:0040  58                :                 cli                             ; And allow interrupts

                             ;-------------------------------------------------------------------------------

                             ; Show the state of the users registers when the BRK was executed.

                             .ShowRegisters:
04:0041  209707            :                 jsr     .NewLine

04:0044  A20908            :                 ldx     #.StrPC
04:0047  208B07            :                 jsr     .Print
04:004A  A50E              :                 lda     REG_PBR                 ; Show PBR and PC
04:004C  20B507            :                 jsr     .Hex2
04:004F  A93A              :                 lda     #':'
04:0051  20CD07            :                 jsr     .UartTx
04:0054  A50D              :                 lda     REG_PC+1
04:0056  EB                :                 xba
04:0057  A50C              :                 lda     REG_PC+0
04:0059  20B007            :                 jsr     .Hex4

04:005C  A20D08            :                 ldx     #.StrE                  ; Show E bit
04:005F  208B07            :                 jsr     .Print
04:0062  A930              :                 lda     #'0'
04:0064  2400              :                 bit     REG_E
04:0066  1001              :                 if mi
04:0068  1A                :                  inc    a
                                             endif
04:0069  20CD07            :                 jsr     .UartTx

04:006C  A21108            :                 ldx     #.StrP                  ; Show P
04:006F  208B07            :                 jsr     .Print
04:0072  A20700            :                 ldx     #7
                                             repeat
04:0075  BD0108            :                  lda    .Mask,x                 ; .. as individual flags
04:0078  2501              :                  and    REG_P
04:007A  08                :                  php
04:007B  BDF907            :                  lda    .Flag,x
04:007E  28                :                  plp
04:007F  D002              :                  if eq
04:0081  A92E              :                   lda   #'.'
                                              endif
04:0083  20CD07            :                  jsr    .UartTx
04:0086  CA                :                  dex
04:0087  10EC              :                 until mi

04:0089  A21508            :                 ldx     #.StrC                  ; Show C
04:008C  208B07            :                 jsr     .Print
04:008F  2400              :                 bit     REG_E
04:0091  300E              :                 bmi     .ShortA

Portable 65xx Assembler [19.05]

04:0093  A920              :                 lda     #M_FLAG
04:0095  2401              :                 bit     REG_P
04:0097  D008              :                 if eq
04:0099  20F107            :                  jsr    .OpenBracket
04:009C  20A007            :                  jsr    .HexCHi
04:009F  8006              :                 else
04:00A1  20A007            : .ShortA:         jsr    .HexCHi
04:00A4  20F107            :                  jsr    .OpenBracket
                                             endif
04:00A7  A502              :                 lda     REG_C+0
04:00A9  20B507            :                 jsr     .Hex2
04:00AC  20F507            :                 jsr     .CloseBracket

04:00AF  A21908            :                 ldx     #.StrX                  ; Show X
04:00B2  208B07            :                 jsr     .Print
04:00B5  2400              :                 bit     REG_E
04:00B7  300E              :                 bmi     .ShortX
04:00B9  A910              :                 lda     #X_FLAG
04:00BB  2401              :                 bit     REG_P
04:00BD  D008              :                 if eq
04:00BF  20F107            :                  jsr    .OpenBracket
04:00C2  20A407            :                  jsr    .HexXHi
04:00C5  8006              :                 else
04:00C7  20A407            : .ShortX:         jsr    .HexXHi
04:00CA  20F107            :                  jsr    .OpenBracket
                                             endif
04:00CD  A504              :                 lda     REG_X+0
04:00CF  20B507            :                 jsr     .Hex2
04:00D2  20F507            :                 jsr     .CloseBracket

04:00D5  A21D08            :                 ldx     #.StrY                  ; Show Y
04:00D8  208B07            :                 jsr     .Print
04:00DB  2400              :                 bit     REG_E
04:00DD  300E              :                 bmi     .ShortY
04:00DF  A910              :                 lda     #X_FLAG
04:00E1  2401              :                 bit     REG_P
04:00E3  D008              :                 if eq
04:00E5  20F107            :                  jsr    .OpenBracket
04:00E8  20A807            :                  jsr    .HexYHi
04:00EB  8006              :                 else
04:00ED  20A807            : .ShortY:         jsr    .HexYHi
04:00F0  20F107            :                  jsr    .OpenBracket
                                             endif
04:00F3  A506              :                 lda     REG_Y+0
04:00F5  20B507            :                 jsr     .Hex2
04:00F8  20F507            :                 jsr     .CloseBracket

04:00FB  A22108            :                 ldx     #.StrDP                 ; Show DP
04:00FE  208B07            :                 jsr     .Print
04:0101  A50B              :                 lda     REG_DP+1
04:0103  EB                :                 xba
04:0104  A50A              :                 lda     REG_DP+0
04:0106  20B007            :                 jsr     .Hex4


Portable 65xx Assembler [19.05]

04:0109  A22608            :                 ldx     #.StrSP                 ; Show SP
04:010C  208B07            :                 jsr     .Print
04:010F  2400              :                 bit     REG_E
04:0111  1008              :                 if mi
04:0113  20AC07            :                  jsr    .HexSPHi
04:0116  20F107            :                  jsr    .OpenBracket
04:0119  8006              :                 else
04:011B  20F107            :                  jsr    .OpenBracket
04:011E  20AC07            :                  jsr    .HexSPHi
                                             endif
04:0121  A508              :                 lda     REG_SP+0
04:0123  20B507            :                 jsr     .Hex2
04:0126  20F507            :                 jsr     .CloseBracket

04:0129  A22B08            :                 ldx     #.StrDBR                ; Show DBR
04:012C  208B07            :                 jsr     .Print
04:012F  A50F              :                 lda     REG_DBR
04:0131  20B507            :                 jsr     .Hex2

                             ;-------------------------------------------------------------------------------

                             ; Read a command from the user into the buffer area. Pressing either BS or DEL
                             ; erases the last character.

                             .NewCommand:
04:0134  6410              :                 stz     CMD_LEN                 ; Clear command buffer
                             .OldCommand:
04:0136  209707            :                 jsr     .NewLine                ; Print the entry prompt
04:0139  A92E              :                 lda     #'.'
04:013B  20CD07            :                 jsr     .UartTx

04:013E  A20000            :                 ldx     #0
                                             repeat
04:0141  8A                :                  txa
04:0142  C510              :                  cmp    CMD_LEN                 ; Any forced characters?
04:0144  F008              :                  break  eq
04:0146  B580              :                  lda    CMD_BUF,x               ; Yes, print one
04:0148  20CD07            :                  jsr    .UartTx
04:014B  E8                :                  inx
04:014C  80F3              :                 forever

                                             repeat
04:014E  20D207            :                  jsr    .UartRx                 ; Read a real character
04:0151  9580              :                  sta    CMD_BUF,x               ; .. and save it

04:0153  C908              :                  cmp    #BS                     ; Map BS to DEL
04:0155  F00C              :                  beq    .BackSpace
04:0157  C90D              :                  cmp    #CR                     ; End of input?
04:0159  F022              :                  break  eq

04:015B  C920              :                  cmp    #' '                    ; Printable?
04:015D  9017              :                  if cs
04:015F  C97F              :                   cmp   #DEL                    ; Delete?
04:0161  9010              :                   if cs

Portable 65xx Assembler [19.05]

04:0163  8A                : .BackSpace:        txa                          ; Is buffer empty?
04:0164  F010              :                    beq  .Beep                   ; Yes, make a noise

04:0166  A908              :                    lda  #BS                     ; Erase the last character
04:0168  20CD07            :                    jsr  .UartTx
04:016B  20ED07            :                    jsr  .Space
04:016E  A908              :                    lda  #BS
04:0170  CA                :                    dex
04:0171  8001              :                   else
04:0173  E8                :                    inx                          ; Keep the last character
                                               endif
04:0174  8002              :                  else
04:0176  A907              : .Beep:            lda   #BEL
                                              endif
04:0178  20CD07            :                  jsr    .UartTx                 ; And echo char, BEL or BS
04:017B  80D1              :                 forever

04:017D  8A                :                 txa                             ; Save the buffer length
04:017E  8510              :                 sta     CMD_LEN

04:0180  A20000            :                 ldx     #0                      ; Set character index
04:0183  20EE04            :                 jsr     .SkipSpaces             ; And get command

04:0186  C90D              :                 cmp     #CR
04:0188  F0AA              :                 beq     .NewCommand

                             ;-------------------------------------------------------------------------------
                             ; Print Help

04:018A  C93F              :                 cmp     #'?'
04:018C  D008              :                 if eq
04:018E  A26008            :                  ldx    #.StrHelp
04:0191  208B07            :                  jsr    .Print
04:0194  809E              :                  bra    .NewCommand
                                             endif

                             ;-------------------------------------------------------------------------------
                             ; Set Default Bank

04:0196  C942              :                 cmp     #'B'
04:0198  D00F              :                 if eq
04:019A  200004            :                  jsr    .GetValue
04:019D  B007              :                  if cc
04:019F  A511              :                   lda   <VALUE+0
04:01A1  8514              :                   sta   <DEFAULT
04:01A3  4C3401            :                   jmp   .NewCommand
                                              endif
04:01A6  4CF703            :                  jmp    .ShowError
                                             endif

                             ;-------------------------------------------------------------------------------
                             ; Disassemble

04:01A9  C944              :                 cmp     #'D'

Portable 65xx Assembler [19.05]

04:01AB  D067              :                 if eq
04:01AD  A50C              :                  lda    <REG_PC+0               ; Default to current PC
04:01AF  8516              :                  sta    <ADDR_S+0
04:01B1  A50D              :                  lda    <REG_PC+1
04:01B3  8517              :                  sta    <ADDR_S+1
04:01B5  A50E              :                  lda    <REG_PBR
04:01B7  8518              :                  sta    <ADDR_S+2
04:01B9  200004            :                  jsr    .GetValue
04:01BC  B00B              :                  if cc
04:01BE  209F04            :                   jsr   .CopyToStart
04:01C1  200004            :                   jsr   .GetValue
04:01C4  B003              :                   if cc
04:01C6  20AC04            :                    jsr  .CopyToEnd
                                               endif
                                              endif

04:01C9  A501              :                  lda    <REG_P
04:01CB  8515              :                  sta    <FLAGS

                                              repeat
04:01CD  20B904            :                   jsr   .ShowAddress
04:01D0  204205            :                   jsr   .ShowBytes
04:01D3  206B05            :                   jsr   .ShowSymbolic

04:01D6  A716              :                   lda   [ADDR_S]
04:01D8  48                :                   pha
04:01D9  A00100            :                   ldy   #1

04:01DC  C918              :                   cmp   #$18                    ; CLC?
04:01DE  D004              :                   if eq
04:01E0  A901              :                    lda  #C_FLAG
04:01E2  800E              :                    bra  .DoREP
                                               endif

04:01E4  C938              :                   cmp   #$38                    ; SEC?
04:01E6  D004              :                   if eq
04:01E8  A901              :                    lda  #C_FLAG
04:01EA  8010              :                    bra  .DoSEP
                                               endif

04:01EC  C9C2              :                   cmp   #$c2                    ; REP?
04:01EE  D006              :                   if eq
04:01F0  B716              :                    lda  [ADDR_S],Y
04:01F2  1415              : .DoREP:            trb  <FLAGS
04:01F4  8008              :                    bra  .NextOpcode
                                               endif

04:01F6  C9E2              :                   cmp   #$e2                    ; SEP?
04:01F8  D004              :                   if eq
04:01FA  B716              :                    lda  [ADDR_S],Y
04:01FC  0415              : .DoSEP:            tsb  <FLAGS
                                               endif

                             .NextOpcode:

Portable 65xx Assembler [19.05]

04:01FE  68                :                   pla
04:01FF  203307            :                   jsr   .OpcodeSize
04:0202  20CE04            :                   jsr   .BumpAddress
04:0205  B00A              :                   break cs
04:0207  20D707            :                   jsr   .Escape
04:020A  B005              :                   break cs
04:020C  20E004            :                   jsr   .CompareAddr
04:020F  B0BC              :                  until cc

04:0211  4C3401            :                  jmp    .NewCommand
                                             endif

                             ;-------------------------------------------------------------------------------
                             ; Fill

04:0214  C946              :                 cmp     #'F'
04:0216  D02B              :                 if eq
04:0218  200004            :                  jsr    .GetValue
04:021B  B023              :                  if cc
04:021D  209F04            :                   jsr   .CopyToStart
04:0220  200004            :                   jsr   .GetValue
04:0223  B01B              :                   if cc
04:0225  20AC04            :                    jsr  .CopyToEnd
04:0228  200004            :                    jsr  .GetValue
04:022B  B013              :                    if cc
                                                 repeat
04:022D  A511              :                      lda <VALUE+0
04:022F  8716              :                      sta [ADDR_S]
04:0231  A901              :                      lda #1
04:0233  20CE04            :                      jsr .BumpAddress
04:0236  B005              :                      break cs
04:0238  20E004            :                      jsr .CompareAddr
04:023B  B0F0              :                     until cc
04:023D  4C3401            :                     jmp .NewCommand
                                                endif
                                               endif
                                              endif
04:0240  4CF703            :                  jmp    .ShowError
                                             endif

                             ;-------------------------------------------------------------------------------
                             ; Go

04:0243  C947              :                 cmp     #'G'
04:0245  D041              :                 if eq
04:0247  200004            :                  jsr    .GetValue               ; Try to get address
04:024A  9010              :                  if cs
04:024C  6600              :                   ror   <REG_E                  ; None, perform reset
04:024E  AFFCFF00          :                   lda   >$00fffc
04:0252  8511              :                   sta   <VALUE+0
04:0254  AFFDFF00          :                   lda   >$00fffd
04:0258  8512              :                   sta   <VALUE+1
04:025A  6413              :                   stz   <VALUE+2
                                              endif

Portable 65xx Assembler [19.05]


04:025C  78                :                  sei
04:025D  A608              :                  ldx    <REG_SP                 ; Restore user stack
04:025F  9A                :                  txs

04:0260  2400              :                  bit    <REG_E                  ; Push PBR if native mode
04:0262  3003              :                  if pl
04:0264  A513              :                   lda   <VALUE+2
04:0266  48                :                   pha
                                              endif
04:0267  A512              :                  lda    <VALUE+1                ; Then PC
04:0269  48                :                  pha
04:026A  A511              :                  lda    <VALUE+0
04:026C  48                :                  pha
04:026D  A501              :                  lda    <REG_P                  ; And flags
04:026F  48                :                  pha
04:0270  A50B              :                  lda    <REG_DP+1               ; Push DP
04:0272  48                :                  pha
04:0273  A50A              :                  lda    <REG_DP+0
04:0275  48                :                  pha
04:0276  A50F              :                  lda    <REG_DBR
04:0278  48                :                  pha
04:0279  A604              :                  ldx    <REG_X                  ; Restore X, Y and C
04:027B  A406              :                  ldy    <REG_Y
04:027D  A503              :                  lda    <REG_C+1
04:027F  EB                :                  xba
04:0280  A502              :                  lda    <REG_C+0
04:0282  2600              :                  rol    <REG_E                  ; Restore CPU mode
04:0284  FB                :                  xce
04:0285  AB                :                  plb                            ; Pull DBR
04:0286  2B                :                  pld                            ; Pull DP
04:0287  40                :                  rti                            ; And start execution
                                             endif

                             ;-------------------------------------------------------------------------------
                             ; Memory

04:0288  C94D              :                 cmp     #'M'
04:028A  D05F              :                 if eq
04:028C  200004            :                  jsr    .GetValue               ; Get start address
04:028F  B057              :                  if cc
04:0291  209F04            :                   jsr   .CopyToStart
04:0294  200004            :                   jsr   .GetValue
04:0297  20AC04            :                   jsr   .CopyToEnd

                                               repeat
04:029A  20B904            :                    jsr  .ShowAddress            ; Display address
04:029D  A00000            :                    ldy  #0
                                                repeat                       ; Then 16 bytes of data
04:02A0  20ED07            :                     jsr .Space
04:02A3  B716              :                     lda [ADDR_S],y
04:02A5  20B507            :                     jsr .Hex2
04:02A8  C8                :                     iny
04:02A9  C01000            :                     cpy #16

Portable 65xx Assembler [19.05]

04:02AC  D0F2              :                    until eq

04:02AE  20ED07            :                    jsr  .Space                  ; Show as ASCII
04:02B1  A97C              :                    lda  #'|'
04:02B3  20CD07            :                    jsr  .UartTx

04:02B6  A00000            :                    ldy  #0
                                                repeat
04:02B9  B716              :                     lda [ADDR_S],y
04:02BB  C920              :                     cmp #' '
04:02BD  B002              :                     if cc
04:02BF  A92E              :                      lda #'.'
                                                 endif
04:02C1  C97F              :                     cmp #DEL
04:02C3  9002              :                     if cs
04:02C5  A92E              :                      lda #'.'
                                                 endif
04:02C7  20CD07            :                     jsr .UartTx
04:02CA  C8                :                     iny
04:02CB  C01000            :                     cpy #16
04:02CE  D0E9              :                    until eq
04:02D0  A97C              :                    lda  #'|'
04:02D2  20CD07            :                    jsr  .UartTx

04:02D5  98                :                    tya                          ; Update the address
04:02D6  20CE04            :                    jsr  .BumpAddress
04:02D9  B00A              :                    break cs
04:02DB  20D707            :                    jsr  .Escape
04:02DE  B005              :                    break cs
04:02E0  20E004            :                    jsr  .CompareAddr
04:02E3  B0B5              :                   until cc

04:02E5  4C3401            :                   jmp   .NewCommand
                                              endif
04:02E8  4CF703            :                  jmp    .ShowError
                                             endif

                             ;-------------------------------------------------------------------------------
                             ; Quit

04:02EB  C951              :                 cmp     #'Q'
04:02ED  D001              :                 if eq
04:02EF  DB                :                  stp
                                             endif

                             ;-------------------------------------------------------------------------------
                             ; Registers

04:02F0  C952              :                 cmp     #'R'
04:02F2  F003829000        :                 if eq
                             .SetRegister:
04:02F7  20EE04            :                  jsr    .SkipSpaces             ; Search for next code
04:02FA  C90D              :                  cmp    #CR                     ; End of line
04:02FC  D003              :                  if eq

Portable 65xx Assembler [19.05]

04:02FE  4C4100            :                   jmp   .ShowRegisters          ; Yes, show new state
                                              endif

04:0301  C941              :                  cmp    #'A'                    ; Set A?
04:0303  D005              :                  if eq
04:0305  A00200            :                   ldy   #REG_C-MON_PAGE
04:0308  803A              :                   bra   .SetByte
                                              endif
04:030A  C942              :                  cmp    #'B'                    ; Set DBR?
04:030C  D005              :                  if eq
04:030E  A00F00            :                   ldy   #REG_DBR-MON_PAGE
04:0311  8031              :                   bra   .SetByte
                                              endif
04:0313  C943              :                  cmp    #'C'                    ; Set C?
04:0315  D005              :                  if eq
04:0317  A00200            :                   ldy   #REG_C-MON_PAGE
04:031A  8052              :                   bra   .SetWord
                                              endif
04:031C  C944              :                  cmp    #'D'                    ; Set DP?
04:031E  D005              :                  if eq
04:0320  A00A00            :                   ldy   #REG_DP-MON_PAGE
04:0323  8049              :                   bra   .SetWord
                                              endif
04:0325  C945              :                  cmp    #'E'                    ; Set E?
04:0327  D014              :                  if eq
04:0329  200004            :                   jsr   .GetValue
04:032C  B00C              :                   if cc
04:032E  6611              :                    ror  <VALUE
04:0330  9004              :                    if cs
04:0332  6409              :                     stz <REG_SP+1
04:0334  E609              :                     inc <REG_SP+1
                                                endif
04:0336  6600              :                    ror  <REG_E
04:0338  80BD              :                    bra  .SetRegister
                                               endif
04:033A  4CF703            :                   jmp   .ShowError
                                              endif
04:033D  C950              :                  cmp    #'P'                    ; Set flags?
04:033F  D014              :                  if eq
04:0341  A00200            :                   ldy   #REG_P-MON_PAGE+1
                             .SetByte:
04:0344  200004            :                   jsr   .GetValue
04:0347  B009              :                   if cc
04:0349  DA                :                    phx
04:034A  BB                :                    tyx
04:034B  A511              :                    lda  <VALUE
04:034D  9500              :                    sta  <0,x
04:034F  FA                :                    plx
04:0350  80A5              :                    bra  .SetRegister
                                               endif#
04:0352  4CF703            :                   jmp   .ShowError
                                              endif
04:0355  C953              :                  cmp    #'S'                    ; Set SP?
04:0357  D005              :                  if eq

Portable 65xx Assembler [19.05]

04:0359  A00800            :                   ldy   #REG_SP-MON_PAGE
04:035C  8010              :                   bra   .SetWord
                                              endif
04:035E  C958              :                  cmp    #'X'                    ; Set X?
04:0360  D005              :                  if eq
04:0362  A00400            :                   ldy   #REG_X-MON_PAGE
04:0365  8007              :                   bra   .SetWord
                                              endif
04:0367  C959              :                  cmp    #'Y'                    ; Set Y?
04:0369  D019              :                  if eq
04:036B  A00600            :                   ldy   #REG_Y-MON_PAGE
                             .SetWord:
04:036E  200004            :                   jsr   .GetValue
04:0371  B00E              :                   if cc
04:0373  DA                :                    phx
04:0374  BB                :                    tyx
04:0375  A511              :                    lda  <VALUE+0
04:0377  9500              :                    sta  <0,x
04:0379  A512              :                    lda  <VALUE+1
04:037B  9501              :                    sta  <1,x
04:037D  FA                :                    plx
04:037E  8276FF            :                    brl  .SetRegister
                                               endif
04:0381  4CF703            :                   jmp   .ShowError
                                              endif

04:0384  4CF703            :                  jmp    .ShowError              ; Anything else is wrong
                                             endif

                             ;-------------------------------------------------------------------------------
                             ; S28 SRECORD loader

04:0387  C953              :                 cmp     #'S'
04:0389  D047              :                 if eq
04:038B  20F604            :                  jsr    .NextChar
04:038E  C932              :                  cmp    #'2'                    ; Only process type '2'
04:0390  D034              :                  if eq
04:0392  204B04            :                   jsr   .GetByte                ; Get the byte count
04:0395  B032              :                   bcs   .InvalidRecord
04:0397  3A                :                   dec   a                       ; Ignore address and checksum
04:0398  3A                :                   dec   a
04:0399  3A                :                   dec   a
04:039A  3A                :                   dec   a
04:039B  F02C              :                   beq   .InvalidRecord
04:039D  302A              :                   bmi   .InvalidRecord
04:039F  8513              :                   sta   <VALUE+2
04:03A1  204B04            :                   jsr   .GetByte                ; Get target address
04:03A4  B023              :                   bcs   .InvalidRecord
04:03A6  8518              :                   sta   <ADDR_S+2
04:03A8  204B04            :                   jsr   .GetByte
04:03AB  B01C              :                   bcs   .InvalidRecord
04:03AD  8517              :                   sta   <ADDR_S+1
04:03AF  204B04            :                   jsr   .GetByte
04:03B2  B015              :                   bcs   .InvalidRecord

Portable 65xx Assembler [19.05]

04:03B4  8516              :                   sta   <ADDR_S+0

                                               repeat
04:03B6  204B04            :                    jsr  .GetByte                ; Get a data byte
04:03B9  B00E              :                    bcs  .InvalidRecord
04:03BB  8716              :                    sta  [ADDR_S]                ; .. and write to memory
04:03BD  A901              :                    lda  #1
04:03BF  20CE04            :                    jsr  .BumpAddress
04:03C2  C613              :                    dec  <VALUE+2
04:03C4  D0F0              :                   until eq
                                              endif
04:03C6  4C3401            :                  jmp    .NewCommand
                             .InvalidRecord:
04:03C9  A24B08            :                  ldx    #.StrInvalid            ; Print the error string
04:03CC  208B07            :                  jsr    .Print
04:03CF  4C3401            :                  jmp    .NewCommand
                                             endif

                             ;-------------------------------------------------------------------------------

04:03D2  C957              :                 cmp     #'W'
04:03D4  D021              :                 if eq
04:03D6  200004            :                  jsr    .GetValue               ; Get start address
04:03D9  B019              :                  if cc
04:03DB  209F04            :                   jsr   .CopyToStart
04:03DE  200004            :                   jsr   .GetValue
04:03E1  B00E              :                   if cc
04:03E3  A511              :                    lda  <VALUE+0
04:03E5  8716              :                    sta  [ADDR_S]

04:03E7  A901              :                    lda  #1
04:03E9  20CE04            :                    jsr  .BumpAddress

04:03EC  A957              :                    lda  #'W'
04:03EE  4C0805            :                    jmp  .BuildCommand
                                               endif
04:03F1  4C3401            :                   jmp   .NewCommand
                                              endif
04:03F4  4CF703            :                  jmp    .ShowError
                                             endif

                             ;-------------------------------------------------------------------------------

                             .ShowError
04:03F7  A23108            :                 ldx     #.StrError              ; Print the error string
04:03FA  208B07            :                 jsr     .Print
04:03FD  4C3401            :                 jmp     .NewCommand

                             ;-------------------------------------------------------------------------------

                             ; Parse a value in for [x[x]:]x[x][x][x] from the command line. if no bank is
                             ; given use the current default bank.

                                             .longa  off

Portable 65xx Assembler [19.05]

                                             .longi  on
                             .GetValue:
04:0400  6411              :                 stz     <VALUE+0                ; Clear result area
04:0402  6412              :                 stz     <VALUE+1
04:0404  A514              :                 lda     <DEFAULT                ; Assume default bank
04:0406  8513              :                 sta     <VALUE+2

04:0408  20EE04            :                 jsr     .SkipSpaces             ; Find first digit
04:040B  206604            :                 jsr     .AddHexDigit
04:040E  9001              :                 if cs
04:0410  60                :                  rts                            ; None, syntax error
                                             endif
04:0411  20F604            :                 jsr     .NextChar               ; Try for a second
04:0414  C93A              :                 cmp     #':'
04:0416  F00C              :                 beq     .FoundBank              ; End of bank
04:0418  206604            :                 jsr     .AddHexDigit
04:041B  B02C              :                 bcs     .ReturnValue
04:041D  20F604            :                 jsr     .NextChar               ; Try for a third
04:0420  C93A              :                 cmp     #':'
04:0422  D01A              :                 if eq
                             .FoundBank:
04:0424  A511              :                  lda    <VALUE+0                ; Set the bank
04:0426  8513              :                  sta    <VALUE+2
04:0428  6411              :                  stz    <VALUE+0
04:042A  20F604            :                  jsr    .NextChar               ; Must be followed by digit
04:042D  206604            :                  jsr    .AddHexDigit
04:0430  9001              :                  if cs
04:0432  60                :                   rts
                                              endif
04:0433  20F604            :                  jsr    .NextChar
04:0436  206604            :                  jsr    .AddHexDigit
04:0439  B00E              :                  bcs    .ReturnValue
04:043B  20F604            :                  jsr    .NextChar
                                             endif
04:043E  206604            :                 jsr     .AddHexDigit            ; Must be offset within bank
04:0441  B006              :                 bcs     .ReturnValue
04:0443  20F604            :                 jsr     .NextChar
04:0446  206604            :                 jsr     .AddHexDigit
04:0449  18                : .ReturnValue:   clc
04:044A  60                :                 rts

                             ; Parse a byte  from the command line and return it in A. Set the carry if a
                             ; non-hex digit is found.

                             .GetByte:
04:044B  6411              :                 stz     <VALUE+0
04:044D  20F604            :                 jsr     .NextChar
04:0450  208604            :                 jsr     .HexDigit
04:0453  B010              :                 if cc
04:0455  0A                :                  asl    a
04:0456  0A                :                  asl    a
04:0457  0A                :                  asl    a
04:0458  0A                :                  asl    a
04:0459  8511              :                  sta    <VALUE

Portable 65xx Assembler [19.05]

04:045B  20F604            :                  jsr    .NextChar
04:045E  208604            :                  jsr    .HexDigit
04:0461  B002              :                  if cc
04:0463  0511              :                   ora   <VALUE+0
                                              endif
                                             endif
04:0465  60                :                 rts

                             ; If the character in A is a hex digit then work it into the value being
                             ; parsed from the line.

                                             .longa  off
                             .AddHexDigit:
04:0466  208604            :                 jsr     .HexDigit
04:0469  B01A              :                 if cc
04:046B  0611              :                  asl    <VALUE+0                ; Shift up the value
04:046D  2612              :                  rol    <VALUE+1
04:046F  0611              :                  asl    <VALUE+0
04:0471  2612              :                  rol    <VALUE+1
04:0473  0611              :                  asl    <VALUE+0
04:0475  2612              :                  rol    <VALUE+1
04:0477  0611              :                  asl    <VALUE+0
04:0479  2612              :                  rol    <VALUE+1
04:047B  18                :                  clc
04:047C  6511              :                  adc    <VALUE+0
04:047E  8511              :                  sta    <VALUE+0
04:0480  9002              :                  if cs
04:0482  E612              :                   inc   <VALUE+1
                                              endif
04:0484  18                :                  clc
                                             endif
04:0485  60                :                 rts

                             ; Returns with the carry clear if the character in A on entry was a hexidecimal
                             ; digit and replaces it with its value.

                                             .longa  off
                             .HexDigit:
04:0486  C930              :                 cmp     #'0'                    ; Numeric digit?
04:0488  9013              :                 if cs
04:048A  C93A              :                  cmp    #'9'+1
04:048C  B003              :                  if cc
04:048E  290F              :                   and   #$0f                    ; Yes, strip out low nybble
04:0490  60                :                   rts
                                              endif

04:0491  C941              :                  cmp    #'A'                    ; Letter A thru F?
04:0493  9008              :                  if cs
04:0495  C947              :                   cmp   #'F'+1
04:0497  B004              :                   if cc
04:0499  E936              :                    sbc  #'A'-11                 ; Yes.
04:049B  18                :                    clc
04:049C  60                :                    rts
                                               endif

Portable 65xx Assembler [19.05]

                                              endif
                                             endif
04:049D  38                :                 sec                             ; No.
04:049E  60                :                 rts

                             ;-------------------------------------------------------------------------------

                             ; Copy the last parsed value into the start address.

                                             .longa off
                             .CopyToStart:
04:049F  A511              :                 lda     <VALUE+0
04:04A1  8516              :                 sta     <ADDR_S+0
04:04A3  A512              :                 lda     <VALUE+1
04:04A5  8517              :                 sta     <ADDR_S+1
04:04A7  A513              :                 lda     <VALUE+2
04:04A9  8518              :                 sta     <ADDR_S+2
04:04AB  60                :                 rts

                             ; Copy the last parsed value into the end address.

                                             .longa off
                             .CopyToEnd:
04:04AC  A511              :                 lda     <VALUE+0
04:04AE  8519              :                 sta     <ADDR_E+0
04:04B0  A512              :                 lda     <VALUE+1
04:04B2  851A              :                 sta     <ADDR_E+1
04:04B4  A513              :                 lda     <VALUE+2
04:04B6  851B              :                 sta     <ADDR_E+2
04:04B8  60                :                 rts

                             ; Print the current starting address value

                             .ShowAddress:
04:04B9  209707            :                 jsr     .NewLine                ; Print the bank
04:04BC  A518              :                 lda     <ADDR_S+2
04:04BE  20B507            :                 jsr     .Hex2
04:04C1  A93A              :                 lda     #':'
04:04C3  20CD07            :                 jsr     .UartTx
04:04C6  A517              :                 lda     <ADDR_S+1               ; And address within it.
04:04C8  EB                :                 xba
04:04C9  A516              :                 lda     <ADDR_S+0
04:04CB  4CB007            :                 jmp     .Hex4

                             ; Add the value in A to the current start address. On return if the carry
                             ; is set then the address wrapped around.

                             .BumpAddress:
04:04CE  18                :                 clc
04:04CF  6516              :                 adc     <ADDR_S+0
04:04D1  8516              :                 sta     <ADDR_S+0
04:04D3  A900              :                 lda     #0
04:04D5  6517              :                 adc     <ADDR_S+1
04:04D7  8517              :                 sta     <ADDR_S+1

Portable 65xx Assembler [19.05]

04:04D9  A900              :                 lda     #0
04:04DB  6518              :                 adc     <ADDR_S+2
04:04DD  8518              :                 sta     <ADDR_S+2
04:04DF  60                :                 rts

                             ; Compare the start and end addresses. Return with carry clear when the start
                             ; is bigger than the end.

                             .CompareAddr:
04:04E0  38                :                 sec
04:04E1  A519              :                 lda     <ADDR_E+0
04:04E3  E516              :                 sbc     <ADDR_S+0
04:04E5  A51A              :                 lda     <ADDR_E+1
04:04E7  E517              :                 sbc     <ADDR_S+1
04:04E9  A51B              :                 lda     <ADDR_E+2
04:04EB  E518              :                 sbc     <ADDR_S+2
04:04ED  60                :                 rts

                             ;-------------------------------------------------------------------------------

                             ; Return the next character on the command line line that is not a space.

                                             .longa  off
                                             .longi  on
                             .SkipSpaces:
                                             repeat
04:04EE  20F604            :                  jsr    .NextChar
04:04F1  C920              :                  cmp #' '                       ; .. until a non-space
04:04F3  F0F9              :                 until ne
04:04F5  60                :                 rts                             ; Done

                             ; Return the next character from the command line converting it to UPPER case.

                                             .longa  off
                             .NextChar:
04:04F6  B580              :                 lda     <CMD_BUF,x              ; Fetch a character
04:04F8  C90D              :                 cmp     #CR
04:04FA  F001              :                 if ne
04:04FC  E8                :                  inx
                                             endif
                             .ToUpper:
04:04FD  C961              :                 cmp     #'a'                    ; If A is 'a'..'z'
04:04FF  9006              :                 if cs
04:0501  C97B              :                  cmp    #'z'+1
04:0503  B002              :                  if cc
04:0505  E91F              :                   sbc   #31                     ; .. then capitalise
                                              endif
                                             endif
04:0507  60                :                 rts

                             ;-------------------------------------------------------------------------------

                                             .longa  off
                                             .longi  on

Portable 65xx Assembler [19.05]

                             .BuildCommand:
04:0508  A20000            :                 ldx     #0
04:050B  203E05            :                 jsr     .AddChar
04:050E  A920              :                 lda     #' '
04:0510  203E05            :                 jsr     .AddChar
04:0513  A513              :                 lda     <VALUE+2
04:0515  203205            :                 jsr     .AddHex2
04:0518  A93A              :                 lda     #':'
04:051A  203E05            :                 jsr     .AddChar
04:051D  A512              :                 lda     <VALUE+1
04:051F  203205            :                 jsr     .AddHex2
04:0522  A511              :                 lda     <VALUE+0
04:0524  203205            :                 jsr     .AddHex2
04:0527  A920              :                 lda     #' '
04:0529  203E05            :                 jsr     .AddChar
04:052C  8A                :                 txa
04:052D  8510              :                 sta     CMD_LEN
04:052F  4C3601            :                 jmp     .OldCommand

                                             .longa  off
                                             .longi  on
                             .AddHex2:
04:0532  48                :                 pha
04:0533  4A                :                 lsr     a
04:0534  4A                :                 lsr     a
04:0535  4A                :                 lsr     a
04:0536  4A                :                 lsr     a
04:0537  203B05            :                 jsr     .AddHex
04:053A  68                :                 pla
                             .AddHex:
04:053B  20C307            :                 jsr     .ToHex
                             .AddChar:
04:053E  9580              :                 sta     <CMD_BUF,x
04:0540  E8                :                 inx
04:0541  60                :                 rts

                             ;-------------------------------------------------------------------------------

                                             .longa  off
                                             .longi  on
                             .ShowBytes:
04:0542  A716              :                 lda     [ADDR_S]
04:0544  203307            :                 jsr     .OpcodeSize             ; Get byte count
04:0547  AA                :                 tax
04:0548  A00000            :                 ldy     #0
                                             repeat
04:054B  20ED07            :                  jsr    .Space                  ; Show a byte
04:054E  B716              :                  lda    [ADDR_S],y
04:0550  20B507            :                  jsr    .Hex2
04:0553  C8                :                  iny
04:0554  CA                :                  dex
04:0555  D0F4              :                 until eq

                                             repeat

Portable 65xx Assembler [19.05]

04:0557  C00400            :                  cpy    #4
04:055A  F00C              :                  break eq
04:055C  C8                :                  iny
04:055D  20ED07            :                  jsr    .Space
04:0560  20ED07            :                  jsr    .Space
04:0563  20ED07            :                  jsr    .Space
04:0566  80EF              :                 forever
04:0568  4CED07            :                 jmp     .Space

                                             .longa  off
                                             .longi  on
                             .ShowSymbolic:
04:056B  A716              :                 lda     [ADDR_S]                ; Fetch the instruction
04:056D  AA                :                 tax
04:056E  BDAC09            :                 lda     OPCODES,x               ; Get opcode
04:0571  A8                :                 tay

                                             long_a
04:0572  C220              +                 rep     #M_FLAG
                           +                 .longa  on
04:0574  B9AC0B            :                 lda     MNEMONICS,y             ; Get the mnemonic
04:0577  48                :                 pha
04:0578  4A                :                 lsr     a
04:0579  4A                :                 lsr     a
04:057A  4A                :                 lsr     a
04:057B  4A                :                 lsr     a
04:057C  4A                :                 lsr     a
04:057D  48                :                 pha
04:057E  4A                :                 lsr     a
04:057F  4A                :                 lsr     a
04:0580  4A                :                 lsr     a
04:0581  4A                :                 lsr     a
04:0582  4A                :                 lsr     a
04:0583  202907            :                 jsr     .ExpandMnem             ; And print it
04:0586  68                :                 pla
04:0587  202907            :                 jsr     .ExpandMnem
04:058A  68                :                 pla
04:058B  202907            :                 jsr     .ExpandMnem
                                             short_a
04:058E  E220              +                 sep     #M_FLAG
                           +                 .longa  off
04:0590  20ED07            :                 jsr     .Space

04:0593  BDAC0A            :                 lda     MODES,x                 ; Get the addressing mode
04:0596  AA                :                 tax
04:0597  7C9A05            :                 jmp     (.MODE_SHOW,x)

                             .MODE_SHOW:
04:059A  4106              :                 .word   .Absolute               ; a
04:059C  CC05              :                 .word   .Accumulator            ; A
04:059E  5406              :                 .word   .AbsoluteX              ; a,x
04:05A0  5906              :                 .word   .AbsoluteY              ; a,y
04:05A2  5E06              :                 .word   .Long                   ; al
04:05A4  7C06              :                 .word   .LongX                  ; al,x

Portable 65xx Assembler [19.05]

04:05A6  8106              :                 .word   .AbsoluteIndirect       ; (a)
04:05A8  8E06              :                 .word   .AbsoluteXIndirect      ; (a,x)
04:05AA  1A06              :                 .word   .Direct                 ; d
04:05AC  0D06              :                 .word   .Stack                  ; d,s
04:05AE  2706              :                 .word   .DirectX                ; d,x
04:05B0  3406              :                 .word   .DirectY                ; d,y
04:05B2  9B06              :                 .word   .DirectIndirect         ; (d)
04:05B4  C506              :                 .word   .DirectIndirectLong     ; [d]
04:05B6  D806              :                 .word   .StackIndirectY         ; (d,s),y
04:05B8  A806              :                 .word   .DirectXIndirect        ; (d,x)
04:05BA  B506              :                 .word   .DirectIndirectY        ; (d),y
04:05BC  D206              :                 .word   .DirectIndirectLongY    ; [d],y
04:05BE  E105              :                 .word   .Implied                ;
04:05C0  E806              :                 .word   .Relative               ; r
04:05C2  0507              :                 .word   .RelativeLong           ; rl
04:05C4  E205              :                 .word   .Move                   ; xyc
04:05C6  D105              :                 .word   .ImmediateM             ; # (A & M)
04:05C8  FF05              :                 .word   .ImmediateByte          ; # (BRK/COP/WDM)
04:05CA  D905              :                 .word   .ImmediateX             ; # (X or Y)

                             .Accumulator:
04:05CC  A941              :                 lda     #'A'
04:05CE  4CCD07            :                 jmp     .UartTx

                             .ImmediateM:
04:05D1  A920              :                 lda     #M_FLAG
04:05D3  2415              :                 bit     <FLAGS
04:05D5  F02F              :                 beq     .ImmediateWord
04:05D7  8026              :                 bra     .ImmediateByte

                             .ImmediateX:
04:05D9  A910              :                 lda     #X_FLAG
04:05DB  2415              :                 bit     <FLAGS
04:05DD  F027              :                 beq     .ImmediateWord
04:05DF  801E              :                 bra     .ImmediateByte

                             .Implied:
04:05E1  60                :                 rts

                             .Move:
04:05E2  A924              :                 lda     #'$'
04:05E4  20CD07            :                 jsr     .UartTx
04:05E7  A00100            :                 ldy     #1
04:05EA  B716              :                 lda     [ADDR_S],Y
04:05EC  20B507            :                 jsr     .Hex2
04:05EF  A92C              :                 lda     #','
04:05F1  20CD07            :                 jsr     .UartTx
04:05F4  A924              :                 lda     #'$'
04:05F6  20CD07            :                 jsr     .UartTx
04:05F9  C8                :                 iny
04:05FA  B716              :                 lda     [ADDR_S],Y
04:05FC  4CB507            :                 jmp     .Hex2

                             .ImmediateByte:

Portable 65xx Assembler [19.05]

04:05FF  A923              :                 lda     #'#'
04:0601  20CD07            :                 jsr     .UartTx
04:0604  8014              :                 bra     .Direct

                             .ImmediateWord:
04:0606  A923              :                 lda     #'#'
04:0608  20CD07            :                 jsr     .UartTx
04:060B  8034              :                 bra     .Absolute

                             .Stack:
04:060D  201A06            :                 jsr     .Direct
04:0610  A92C              :                 lda     #','
04:0612  20CD07            :                 jsr     .UartTx
04:0615  A953              :                 lda     #'S'
04:0617  4CCD07            :                 jmp     .UartTx

                             .Direct:
04:061A  A924              :                 lda     #'$'
04:061C  20CD07            :                 jsr     .UartTx
04:061F  A00100            :                 ldy     #1
04:0622  B716              :                 lda     [ADDR_S],Y
04:0624  4CB507            :                 jmp     .Hex2

                             .DirectX:
04:0627  201A06            :                 jsr     .Direct
04:062A  A92C              : .X:             lda     #','
04:062C  20CD07            :                 jsr     .UartTx
04:062F  A958              :                 lda     #'X'
04:0631  4CCD07            :                 jmp     .UartTx

                             .DirectY:
04:0634  201A06            :                 jsr     .Direct
04:0637  A92C              : .Y:             lda     #','
04:0639  20CD07            :                 jsr     .UartTx
04:063C  A959              :                 lda     #'Y'
04:063E  4CCD07            :                 jmp     .UartTx

                             .Absolute:
04:0641  A924              :                 lda     #'$'
04:0643  20CD07            :                 jsr     .UartTx
04:0646  A00200            :                 ldy     #2
04:0649  B716              :                 lda     [ADDR_S],Y
04:064B  20B507            :                 jsr     .Hex2
04:064E  88                :                 dey
04:064F  B716              :                 lda     [ADDR_S],Y
04:0651  4CB507            :                 jmp     .Hex2

                             .AbsoluteX:
04:0654  204106            :                 jsr     .Absolute
04:0657  80D1              :                 bra     .X

                             .AbsoluteY:
04:0659  204106            :                 jsr     .Absolute
04:065C  80D9              :                 bra     .Y

Portable 65xx Assembler [19.05]


                             .Long:
04:065E  A924              :                 lda     #'$'
04:0660  20CD07            :                 jsr     .UartTx
04:0663  A00300            :                 ldy     #3
04:0666  B716              :                 lda     [ADDR_S],Y
04:0668  20B507            :                 jsr     .Hex2
04:066B  A93A              :                 lda     #':'
04:066D  20CD07            :                 jsr     .UartTx
04:0670  88                :                 dey
04:0671  B716              :                 lda     [ADDR_S],Y
04:0673  20B507            :                 jsr     .Hex2
04:0676  88                :                 dey
04:0677  B716              :                 lda     [ADDR_S],Y
04:0679  4CB507            :                 jmp     .Hex2

                             .LongX:
04:067C  205E06            :                 jsr     .Long
04:067F  80A9              :                 bra     .X

                             .AbsoluteIndirect:
04:0681  A928              :                 lda     #'('
04:0683  20CD07            :                 jsr     .UartTx
04:0686  204106            :                 jsr     .Absolute
04:0689  A929              :                 lda     #')'
04:068B  4CCD07            :                 jmp     .UartTx

                             .AbsoluteXIndirect:
04:068E  A928              :                 lda     #'('
04:0690  20CD07            :                 jsr     .UartTx
04:0693  205406            :                 jsr     .AbsoluteX
04:0696  A929              :                 lda     #')'
04:0698  4CCD07            :                 jmp     .UartTx

                             .DirectIndirect:
04:069B  A928              :                 lda     #'('
04:069D  20CD07            :                 jsr     .UartTx
04:06A0  201A06            :                 jsr     .Direct
04:06A3  A929              :                 lda     #')'
04:06A5  4CCD07            :                 jmp     .UartTx

                             .DirectXIndirect:
04:06A8  A928              :                 lda     #'('
04:06AA  20CD07            :                 jsr     .UartTx
04:06AD  202706            :                 jsr     .DirectX
04:06B0  A929              :                 lda     #')'
04:06B2  4CCD07            :                 jmp     .UartTx

                             .DirectIndirectY:
04:06B5  A928              :                 lda     #'('
04:06B7  20CD07            :                 jsr     .UartTx
04:06BA  201A06            :                 jsr     .Direct
04:06BD  A929              :                 lda     #')'
04:06BF  20CD07            :                 jsr     .UartTx

Portable 65xx Assembler [19.05]

04:06C2  4C3706            :                 jmp     .Y

                             .DirectIndirectLong:
04:06C5  A95B              :                 lda     #'['
04:06C7  20CD07            :                 jsr     .UartTx
04:06CA  201A06            :                 jsr     .Direct
04:06CD  A95D              :                 lda     #']'
04:06CF  4CCD07            :                 jmp     .UartTx

                             .DirectIndirectLongY:
04:06D2  20C506            :                 jsr     .DirectIndirectLong
04:06D5  4C3706            :                 jmp     .Y

                             .StackIndirectY:
04:06D8  A928              :                 lda     #'('
04:06DA  20CD07            :                 jsr     .UartTx
04:06DD  200D06            :                 jsr     .Stack
04:06E0  A929              :                 lda     #')'
04:06E2  20CD07            :                 jsr     .UartTx
04:06E5  4C3706            :                 jmp     .Y

                             .Relative:
04:06E8  A617              :                 ldx     <ADDR_S+1               ; Work out next PC
04:06EA  A516              :                 lda     <ADDR_S+0
04:06EC  18                :                 clc
04:06ED  6902              :                 adc     #2
04:06EF  9001              :                 bcc     $+3
04:06F1  E8                :                 inx

04:06F2  48                :                 pha                             ; Add relative offset
04:06F3  A00100            :                 ldy     #1
04:06F6  B716              :                 lda     [ADDR_S],y
04:06F8  1001              :                 bpl     $+3
04:06FA  CA                :                 dex
04:06FB  18                :                 clc
04:06FC  6301              :                 adc     1,s
04:06FE  8301              :                 sta     1,s
04:0700  9001              :                 bcc     $+3
04:0702  E8                :                 inx
04:0703  8016              :                 bra     .Addr

                             .RelativeLong:
04:0705  A617              :                 ldx     ADDR_S+1                ; Work out next PC
04:0707  A516              :                 lda     ADDR_S+0
04:0709  18                :                 clc
04:070A  6903              :                 adc     #3
04:070C  9001              :                 bcc     $+3
04:070E  E8                :                 inx

04:070F  18                :                 clc                             ; Add relative offset
04:0710  A00100            :                 ldy     #1
04:0713  7716              :                 adc     [ADDR_S],y
04:0715  48                :                 pha
04:0716  C8                :                 iny

Portable 65xx Assembler [19.05]

04:0717  8A                :                 txa
04:0718  7716              :                 adc     [ADDR_S],Y
04:071A  AA                :                 tax

                             .Addr:
04:071B  A924              :                 lda     #'$'                    ; Print address
04:071D  20CD07            :                 jsr     .UartTx
04:0720  8A                :                 txa
04:0721  20B507            :                 jsr     .Hex2
04:0724  68                :                 pla
04:0725  4CB507            :                 jmp     .Hex2



04:0728  60                :                 rts


                                             .longa  on
                                             .longi  on
                             .ExpandMnem:
04:0729  291F00            :                 and     #$1f
04:072C  18                :                 clc
04:072D  694000            :                 adc     #'@'
04:0730  4CCD07            :                 jmp     .UartTx

                                             .longa  off
                                             .longi  on
                             .OpcodeSize:
04:0733  A716              :                 lda     [ADDR_S]
04:0735  AA                :                 tax
04:0736  BDAC0A            :                 lda     MODES,x
04:0739  AA                :                 tax
04:073A  7C3D07            :                 jmp     (.MODE_SIZE,x)

                             .MODE_SIZE:
04:073D  8507              :                 .word   .Size3                  ; a
04:073F  7F07              :                 .word   .Size1                  ; A
04:0741  8507              :                 .word   .Size3                  ; a,x
04:0743  8507              :                 .word   .Size3                  ; a,y
04:0745  8807              :                 .word   .Size4                  ; al
04:0747  8807              :                 .word   .Size4                  ; al,x
04:0749  8507              :                 .word   .Size3                  ; (a)
04:074B  8507              :                 .word   .Size3                  ; (a,x)
04:074D  8207              :                 .word   .Size2                  ; d
04:074F  8207              :                 .word   .Size2                  ; d,s
04:0751  8207              :                 .word   .Size2                  ; d,x
04:0753  8207              :                 .word   .Size2                  ; d,y
04:0755  8207              :                 .word   .Size2                  ; (d)
04:0757  8207              :                 .word   .Size2                  ; [d]
04:0759  8207              :                 .word   .Size2                  ; (d,s),y
04:075B  8207              :                 .word   .Size2                  ; (d,x)
04:075D  8207              :                 .word   .Size2                  ; (d),y
04:075F  8207              :                 .word   .Size2                  ; [d],y
04:0761  7F07              :                 .word   .Size1                  ;

Portable 65xx Assembler [19.05]

04:0763  8207              :                 .word   .Size2                  ; r
04:0765  8507              :                 .word   .Size3                  ; rl
04:0767  8507              :                 .word   .Size3                  ; xyc
04:0769  6F07              :                 .word   .TestM                  ; # (A & M)
04:076B  8207              :                 .word   .Size2                  ; # (BRK/COP/WDM)
04:076D  7707              :                 .word   .TestX                  ; # (X or Y)

                             .TestM:
04:076F  A920              :                 lda     #M_FLAG                 ; Is M bit set?
04:0771  2515              :                 and     <FLAGS
04:0773  F010              :                 beq     .Size3                  ; No, word
04:0775  800B              :                 bra     .Size2                  ; else byte

                             .TestX:
04:0777  A910              :                 lda     #X_FLAG                 ; Is X bit set?
04:0779  2515              :                 and     <FLAGS
04:077B  F008              :                 beq     .Size3                  ; No, word
04:077D  8003              :                 bra     .Size2                  ; else byte

                             .Size1:
04:077F  A901              :                 lda     #1
04:0781  60                :                 rts
                             .Size2:
04:0782  A902              :                 lda     #2
04:0784  60                :                 rts
                             .Size3
04:0785  A903              :                 lda     #3
04:0787  60                :                 rts
                             .Size4:
04:0788  A904              :                 lda     #4
04:078A  60                :                 rts

                             ;-------------------------------------------------------------------------------

                             ; Print the null terminated string pointed to the address in the X register to
                             ; the UART.

                                             .longa  off
                                             .longi  on
                             .Print:
                                             repeat
04:078B  BD0000            :                  lda    !0,x
04:078E  D001              :                  if eq
04:0790  60                :                   rts
                                              endif
04:0791  20CD07            :                  jsr    .UartTx
04:0794  E8                :                  inx
04:0795  80F4              :                 forever

                             ; Output a CR+LF character sequence to move the cursor to the next line.

                                             .longa  off
                             .NewLine:
04:0797  A90D              :                 lda     #CR

Portable 65xx Assembler [19.05]

04:0799  20CD07            :                 jsr     .UartTx
04:079C  A90A              :                 lda     #LF
04:079E  802D              :                 bra     .UartTx

                             ;-------------------------------------------------------------------------------

                             ; Output the high byte of the C register in hex.

                                             .longa  off
                             .HexCHi:
04:07A0  A503              :                 lda     <REG_C+1
04:07A2  8011              :                 bra     .Hex2

                             ; Output the high byte of the X register in hex.

                                             .longa  off
                             .HexXHi:
04:07A4  A505              :                 lda     <REG_X+1
04:07A6  800D              :                 bra     .Hex2

                             ; Output the high byte of the Y register in hex.

                                             .longa  off
                             .HexYHi:
04:07A8  A507              :                 lda     <REG_Y+1
04:07AA  8009              :                 bra     .Hex2

                             ; Output the high byte of the SP register in hex.

                                             .longa  off
                             .HexSPHi:
04:07AC  A509              :                 lda     <REG_SP+1
04:07AE  8005              :                 bra     .Hex2

                             ; Print the value in the C register in hex.

                                             .longa  off
                             .Hex4:
04:07B0  EB                :                 xba                             ; Swap the high and low bytes
04:07B1  20B507            :                 jsr     .Hex2                   ; Print the high byte
04:07B4  EB                :                 xba                             ; Swap back then ..

                             ; Print the value in the A registers in hex.

                                             .longa  off
                             .Hex2:
04:07B5  48                :                 pha                             ; Save the byte
04:07B6  4A                :                 lsr     a                       ; Shift down the high nybble
04:07B7  4A                :                 lsr     a
04:07B8  4A                :                 lsr     a
04:07B9  4A                :                 lsr     a
04:07BA  20BE07            :                 jsr     .Hex                    ; Print it
04:07BD  68                :                 pla                             ; Recover the byte then ..


Portable 65xx Assembler [19.05]

                             ; Print the value in the low nybble of A in hex.

                                             .longa  off
                             .Hex:
04:07BE  20C307            :                 jsr     .ToHex
04:07C1  800A              :                 bra     .UartTx


                             .ToHex
04:07C3  290F              :                 and     #$0f                    ; Strip out the low nybble
04:07C5  F8                :                 sed
04:07C6  18                :                 clc                             ; And convert using BCD
04:07C7  6990              :                 adc     #$90
04:07C9  6940              :                 adc     #$40
04:07CB  D8                :                 cld
04:07CC  60                :                 rts

                             ;-------------------------------------------------------------------------------

                             ; Transmit the character in A using the UART. Poll the UART to see if its
                             ; busy before outputing the character.

                                             .longa  ?
                             .UartTx:
04:07CD  2200F000          :                 jsl     $00f000
04:07D1  60                :                 rts

                             ; Receive a character from UART performing a polled wait for data to arrive.

                                             .longa  ?
                             .UartRx:
04:07D2  2203F000          :                 jsl     >$00f003
04:07D6  60                :                 rts

                             ; If there are any characters in the UART RX buffer then check for an ESC and
                             ; return with carry set if it is,

                                             .longa  off
                             .Escape:
                                             repeat
04:07D7  2206F000          :                  jsl    >$00f006                ; Is the buffer empty?
04:07DB  C900              :                  cmp    #0
04:07DD  F00C              :                  break eq
04:07DF  2203F000          :                  jsl    >$00f003                ; .. No, fetch a character
04:07E3  C91B              :                  cmp    #ESC                    ; Test for escape
04:07E5  D002              :                  if eq
04:07E7  38                :                   sec                           ; Signal stop.
04:07E8  60                :                   rts
                                              endif
04:07E9  80EC              :                 forever
04:07EB  18                :                 clc                             ; Continue output
04:07EC  60                :                 rts

                             ; Output an openning bracket character.

Portable 65xx Assembler [19.05]


                                             .longa  off
                             .Space:
04:07ED  A920              :                 lda     #' '
04:07EF  80DC              :                 bra     .UartTx

                             ; Output an openning bracket character.

                                             .longa  off
                             .OpenBracket:
04:07F1  A95B              :                 lda     #'['
04:07F3  80D8              :                 bra     .UartTx

                             ; Output a closing bracket character.

                                             .longa  off
                             .CloseBracket:
04:07F5  A95D              :                 lda     #']'
04:07F7  80D4              :                 bra     .UartTx

                             ;-------------------------------------------------------------------------------

                             ; 65xx Flags Bits

04:07F9  435A4944584D564E  : .Flag:          .byte   'C','Z','I','D','X','M','V','N'
04:0801  0102040810204080  : .Mask:          .byte   $01,$02,$04,$08,$10,$20,$40,$80

                             ; Various Strings

04:0809  50433D00          : .StrPC:         .byte   "PC=",0
04:080D  20453D00          : .StrE:          .byte   " E=",0
04:0811  20503D00          : .StrP:          .byte   " P=",0
04:0815  20433D00          : .StrC:          .byte   " C=",0
04:0819  20583D00          : .StrX:          .byte   " X=",0
04:081D  20593D00          : .StrY:          .byte   " Y=",0
04:0821  2044503D00        : .StrDP:         .byte   " DP=",0
04:0826  2053503D00        : .StrSP:         .byte   " SP=",0
04:082B  204442523D00      : .StrDBR:        .byte   " DBR=",0

04:0831  0D0A4572726F7220> : .StrError:      .byte   CR,LF,"Error - Type ? for help",0
04:084B  0D0A496E76616C69> : .StrInvalid:    .byte   CR,LF,"Invalid S28 record",0

                             .StrHelp:
04:0860  0D0A436F6D6D616E> :                 .byte   CR,LF,"Commands:"
04:086B  0D0A422078780909> :                 .byte   CR,LF,"B xx\t\t\t\t- Set default bank"
04:0887  0D0A44205B73733A> :                 .byte   CR,LF,"D [ss:]ssss [[ee:]eeee]\t\t- Disassemble memory"
04:08B6  0D0A46205B73733A> :                 .byte   CR,LF,"F [ss:]ssss [ee:]eeee xx\t- Fill memory"
04:08DE  0D0A47205B5B7878> :                 .byte   CR,LF,"G [[xx:]xxxx]\t\t\t- Execute or RESET"
04:0902  0D0A4D205B73733A> :                 .byte   CR,LF,"M [ss:]ssss [[ee:]eeee]\t\t- Display memory"
04:092D  0D0A51090909092D> :                 .byte   CR,LF,"Q\t\t\t\t- Stop emulator"
04:0943  0D0A522072656720> :                 .byte   CR,LF,"R reg xx ..\t\t\t- Change/Show registers"
04:096A  0D0A532E2E2E0909> :                 .byte   CR,LF,"S...\t\t\t\t- Load S28 record"
04:0985  0D0A57205B73733A> :                 .byte   CR,LF,"W [ss:]ssss bb\t\t\t- Write memory byte"
04:09AB  00                :                 .byte   0

Portable 65xx Assembler [19.05]


                             ;-------------------------------------------------------------------------------

                             OPCODES:
04:09AC  16522852          :                 .byte   OP_BRK,OP_ORA,OP_COP,OP_ORA     ; 00
04:09B0  A0520452          :                 .byte   OP_TSB,OP_ORA,OP_ASL,OP_ORA
04:09B4  6252045E          :                 .byte   OP_PHP,OP_ORA,OP_ASL,OP_PHD
04:09B8  A0520452          :                 .byte   OP_TSB,OP_ORA,OP_ASL,OP_ORA
04:09BC  12525252          :                 .byte   OP_BPL,OP_ORA,OP_ORA,OP_ORA     ; 10
04:09C0  9E520452          :                 .byte   OP_TRB,OP_ORA,OP_ASL,OP_ORA
04:09C4  1E52369A          :                 .byte   OP_CLC,OP_ORA,OP_INC,OP_TCS
04:09C8  9E520452          :                 .byte   OP_TRB,OP_ORA,OP_ASL,OP_ORA
04:09CC  42024002          :                 .byte   OP_JSR,OP_AND,OP_JSL,OP_AND     ; 20
04:09D0  0C027602          :                 .byte   OP_BIT,OP_AND,OP_ROL,OP_AND
04:09D4  6E02766C          :                 .byte   OP_PLP,OP_AND,OP_ROL,OP_PLD
04:09D8  0C027602          :                 .byte   OP_BIT,OP_AND,OP_ROL,OP_AND
04:09DC  0E020202          :                 .byte   OP_BMI,OP_AND,OP_AND,OP_AND     ; 30
04:09E0  0C027602          :                 .byte   OP_BIT,OP_AND,OP_ROL,OP_AND
04:09E4  82022EA2          :                 .byte   OP_SEC,OP_AND,OP_DEC,OP_TSC
04:09E8  0C027602          :                 .byte   OP_BIT,OP_AND,OP_ROL,OP_AND
04:09EC  7A34B234          :                 .byte   OP_RTI,OP_EOR,OP_WDM,OP_EOR     ; 40
04:09F0  4E344A34          :                 .byte   OP_MVP,OP_EOR,OP_LSR,OP_EOR
04:09F4  5A344A60          :                 .byte   OP_PHA,OP_EOR,OP_LSR,OP_PHK
04:09F8  3E344A34          :                 .byte   OP_JMP,OP_EOR,OP_LSR,OP_EOR
04:09FC  1A343434          :                 .byte   OP_BVC,OP_EOR,OP_EOR,OP_EOR     ; 50
04:0A00  4C344A34          :                 .byte   OP_MVN,OP_EOR,OP_LSR,OP_EOR
04:0A04  22346698          :                 .byte   OP_CLI,OP_EOR,OP_PHY,OP_TCD
04:0A08  3E344A34          :                 .byte   OP_JMP,OP_EOR,OP_LSR,OP_EOR
04:0A0C  7E005800          :                 .byte   OP_RTS,OP_ADC,OP_PER,OP_ADC     ; 60
04:0A10  92007800          :                 .byte   OP_STZ,OP_ADC,OP_ROR,OP_ADC
04:0A14  6800787C          :                 .byte   OP_PLA,OP_ADC,OP_ROR,OP_RTL
04:0A18  3E007800          :                 .byte   OP_JMP,OP_ADC,OP_ROR,OP_ADC
04:0A1C  1C000000          :                 .byte   OP_BVS,OP_ADC,OP_ADC,OP_ADC     ; 70
04:0A20  92007800          :                 .byte   OP_STZ,OP_ADC,OP_ROR,OP_ADC
04:0A24  8600729C          :                 .byte   OP_SEI,OP_ADC,OP_PLY,OP_TDC
04:0A28  3E007800          :                 .byte   OP_JMP,OP_ADC,OP_ROR,OP_ADC
04:0A2C  148A188A          :                 .byte   OP_BRA,OP_STA,OP_BRL,OP_STA     ; 80
04:0A30  908A8E8A          :                 .byte   OP_STY,OP_STA,OP_STX,OP_STA
04:0A34  320CA65C          :                 .byte   OP_DEY,OP_BIT,OP_TXA,OP_PHB
04:0A38  908A8E8A          :                 .byte   OP_STY,OP_STA,OP_STX,OP_STA
04:0A3C  068A8A8A          :                 .byte   OP_BCC,OP_STA,OP_STA,OP_STA     ; 90
04:0A40  908A8E8A          :                 .byte   OP_STY,OP_STA,OP_STX,OP_STA
04:0A44  AC8AA8AA          :                 .byte   OP_TYA,OP_STA,OP_TXS,OP_TXY
04:0A48  928A928A          :                 .byte   OP_STZ,OP_STA,OP_STZ,OP_STA
04:0A4C  48444644          :                 .byte   OP_LDY,OP_LDA,OP_LDX,OP_LDA     ; A0
04:0A50  48444644          :                 .byte   OP_LDY,OP_LDA,OP_LDX,OP_LDA
04:0A54  9644946A          :                 .byte   OP_TAY,OP_LDA,OP_TAX,OP_PLB
04:0A58  48444644          :                 .byte   OP_LDY,OP_LDA,OP_LDX,OP_LDA
04:0A5C  08444444          :                 .byte   OP_BCS,OP_LDA,OP_LDA,OP_LDA     ; B0
04:0A60  44484644          :                 .byte   OP_LDA,OP_LDY,OP_LDX,OP_LDA
04:0A64  2444A4AE          :                 .byte   OP_CLV,OP_LDA,OP_TSX,OP_TYX
04:0A68  48444644          :                 .byte   OP_LDY,OP_LDA,OP_LDX,OP_LDA
04:0A6C  2C267426          :                 .byte   OP_CPY,OP_CMP,OP_REP,OP_CMP     ; C0
04:0A70  2C262E26          :                 .byte   OP_CPY,OP_CMP,OP_DEC,OP_CMP

Portable 65xx Assembler [19.05]

04:0A74  3A2630B0          :                 .byte   OP_INY,OP_CMP,OP_DEX,OP_WAI
04:0A78  2C262E26          :                 .byte   OP_CPY,OP_CMP,OP_DEC,OP_CMP
04:0A7C  10262626          :                 .byte   OP_BNE,OP_CMP,OP_CMP,OP_CMP     ; D0
04:0A80  56262E26          :                 .byte   OP_PEI,OP_CMP,OP_DEC,OP_CMP
04:0A84  2026648C          :                 .byte   OP_CLD,OP_CMP,OP_PHX,OP_STP
04:0A88  3C262E26          :                 .byte   OP_JML,OP_CMP,OP_DEC,OP_CMP
04:0A8C  2A808880          :                 .byte   OP_CPX,OP_SBC,OP_SEP,OP_SBC     ; E0
04:0A90  2A803680          :                 .byte   OP_CPX,OP_SBC,OP_INC,OP_SBC
04:0A94  388050B4          :                 .byte   OP_INX,OP_SBC,OP_NOP,OP_XBA
04:0A98  2A803680          :                 .byte   OP_CPX,OP_SBC,OP_INC,OP_SBC
04:0A9C  0A808080          :                 .byte   OP_BEQ,OP_SBC,OP_SBC,OP_SBC     ; F0
04:0AA0  54803680          :                 .byte   OP_PEA,OP_SBC,OP_INC,OP_SBC
04:0AA4  848070B6          :                 .byte   OP_SED,OP_SBC,OP_PLX,OP_XCE
04:0AA8  42803680          :                 .byte   OP_JSR,OP_SBC,OP_INC,OP_SBC

                             MODES:
04:0AAC  2E1E2E12          :                 .byte   MD_INT,MD_DIX,MD_INT,MD_STK     ; 00
04:0AB0  1010101A          :                 .byte   MD_DPG,MD_DPG,MD_DPG,MD_DLI
04:0AB4  242C0224          :                 .byte   MD_IMP,MD_IMM,MD_ACC,MD_IMP
04:0AB8  00000008          :                 .byte   MD_ABS,MD_ABS,MD_ABS,MD_ALG
04:0ABC  2620181C          :                 .byte   MD_REL,MD_DIY,MD_DIN,MD_SKY     ; 10
04:0AC0  10141422          :                 .byte   MD_DPG,MD_DPX,MD_DPX,MD_DLY
04:0AC4  24060224          :                 .byte   MD_IMP,MD_ABY,MD_ACC,MD_IMP
04:0AC8  0004040A          :                 .byte   MD_ABS,MD_ABX,MD_ABX,MD_ALX
04:0ACC  001E0812          :                 .byte   MD_ABS,MD_DIX,MD_ALG,MD_STK     ; 20
04:0AD0  1010101A          :                 .byte   MD_DPG,MD_DPG,MD_DPG,MD_DLI
04:0AD4  242C0224          :                 .byte   MD_IMP,MD_IMM,MD_ACC,MD_IMP
04:0AD8  00000008          :                 .byte   MD_ABS,MD_ABS,MD_ABS,MD_ALG
04:0ADC  2620181C          :                 .byte   MD_REL,MD_DIY,MD_DIN,MD_SKY     ; 30
04:0AE0  14141422          :                 .byte   MD_DPX,MD_DPX,MD_DPX,MD_DLY
04:0AE4  24060224          :                 .byte   MD_IMP,MD_ABY,MD_ACC,MD_IMP
04:0AE8  0404040A          :                 .byte   MD_ABX,MD_ABX,MD_ABX,MD_ALX
04:0AEC  241E2E12          :                 .byte   MD_IMP,MD_DIX,MD_INT,MD_STK     ; 40
04:0AF0  2A10101A          :                 .byte   MD_MOV,MD_DPG,MD_DPG,MD_DLI
04:0AF4  242C0224          :                 .byte   MD_IMP,MD_IMM,MD_ACC,MD_IMP
04:0AF8  00000008          :                 .byte   MD_ABS,MD_ABS,MD_ABS,MD_ALG
04:0AFC  2620181C          :                 .byte   MD_REL,MD_DIY,MD_DIN,MD_SKY     ; 50
04:0B00  2A141422          :                 .byte   MD_MOV,MD_DPX,MD_DPX,MD_DLY
04:0B04  24062424          :                 .byte   MD_IMP,MD_ABY,MD_IMP,MD_IMP
04:0B08  0804040A          :                 .byte   MD_ALG,MD_ABX,MD_ABX,MD_ALX
04:0B0C  241E2412          :                 .byte   MD_IMP,MD_DIX,MD_IMP,MD_STK     ; 60
04:0B10  1010101A          :                 .byte   MD_DPG,MD_DPG,MD_DPG,MD_DLI
04:0B14  242C0224          :                 .byte   MD_IMP,MD_IMM,MD_ACC,MD_IMP
04:0B18  0C000008          :                 .byte   MD_AIN,MD_ABS,MD_ABS,MD_ALG
04:0B1C  2620181C          :                 .byte   MD_REL,MD_DIY,MD_DIN,MD_SKY     ; 70
04:0B20  14141422          :                 .byte   MD_DPX,MD_DPX,MD_DPX,MD_DLY
04:0B24  24062424          :                 .byte   MD_IMP,MD_ABY,MD_IMP,MD_IMP
04:0B28  0E04040A          :                 .byte   MD_AIX,MD_ABX,MD_ABX,MD_ALX
04:0B2C  261E2812          :                 .byte   MD_REL,MD_DIX,MD_RLG,MD_STK     ; 80
04:0B30  1010101A          :                 .byte   MD_DPG,MD_DPG,MD_DPG,MD_DLI
04:0B34  242C2424          :                 .byte   MD_IMP,MD_IMM,MD_IMP,MD_IMP
04:0B38  00000008          :                 .byte   MD_ABS,MD_ABS,MD_ABS,MD_ALG
04:0B3C  2620181C          :                 .byte   MD_REL,MD_DIY,MD_DIN,MD_SKY     ; 90
04:0B40  14141622          :                 .byte   MD_DPX,MD_DPX,MD_DPY,MD_DLY

Portable 65xx Assembler [19.05]

04:0B44  24062424          :                 .byte   MD_IMP,MD_ABY,MD_IMP,MD_IMP
04:0B48  0004040A          :                 .byte   MD_ABS,MD_ABX,MD_ABX,MD_ALX
04:0B4C  301E3012          :                 .byte   MD_IMX,MD_DIX,MD_IMX,MD_STK     ; A0
04:0B50  1010101A          :                 .byte   MD_DPG,MD_DPG,MD_DPG,MD_DLI
04:0B54  242C2424          :                 .byte   MD_IMP,MD_IMM,MD_IMP,MD_IMP
04:0B58  00000008          :                 .byte   MD_ABS,MD_ABS,MD_ABS,MD_ALG
04:0B5C  2620181C          :                 .byte   MD_REL,MD_DIY,MD_DIN,MD_SKY     ; B0
04:0B60  14141622          :                 .byte   MD_DPX,MD_DPX,MD_DPY,MD_DLY
04:0B64  24062424          :                 .byte   MD_IMP,MD_ABY,MD_IMP,MD_IMP
04:0B68  0404060A          :                 .byte   MD_ABX,MD_ABX,MD_ABY,MD_ALX
04:0B6C  301E2E12          :                 .byte   MD_IMX,MD_DIX,MD_INT,MD_STK     ; C0
04:0B70  1010101A          :                 .byte   MD_DPG,MD_DPG,MD_DPG,MD_DLI
04:0B74  242C2424          :                 .byte   MD_IMP,MD_IMM,MD_IMP,MD_IMP
04:0B78  00000008          :                 .byte   MD_ABS,MD_ABS,MD_ABS,MD_ALG
04:0B7C  2620181C          :                 .byte   MD_REL,MD_DIY,MD_DIN,MD_SKY     ; D0
04:0B80  24141422          :                 .byte   MD_IMP,MD_DPX,MD_DPX,MD_DLY
04:0B84  24062424          :                 .byte   MD_IMP,MD_ABY,MD_IMP,MD_IMP
04:0B88  0C04040A          :                 .byte   MD_AIN,MD_ABX,MD_ABX,MD_ALX
04:0B8C  301E2E12          :                 .byte   MD_IMX,MD_DIX,MD_INT,MD_STK     ; E0
04:0B90  1010101A          :                 .byte   MD_DPG,MD_DPG,MD_DPG,MD_DLI
04:0B94  242C2424          :                 .byte   MD_IMP,MD_IMM,MD_IMP,MD_IMP
04:0B98  00000008          :                 .byte   MD_ABS,MD_ABS,MD_ABS,MD_ALG
04:0B9C  2620181C          :                 .byte   MD_REL,MD_DIY,MD_DIN,MD_SKY     ; F0
04:0BA0  00141422          :                 .byte   MD_ABS,MD_DPX,MD_DPX,MD_DLY
04:0BA4  24062424          :                 .byte   MD_IMP,MD_ABY,MD_IMP,MD_IMP
04:0BA8  0E04040A          :                 .byte   MD_AIX,MD_ABX,MD_ABX,MD_ALX

                             MNEMONICS:
                                             MNEM    'A','D','C'
04:0BAC  8304              +                 .word   (('A'-'@')<<10)|(('D'-'@')<<5)|(('C'-'@')<<0)
                                             MNEM    'A','N','D'
04:0BAE  C405              +                 .word   (('A'-'@')<<10)|(('N'-'@')<<5)|(('D'-'@')<<0)
                                             MNEM    'A','S','L'
04:0BB0  6C06              +                 .word   (('A'-'@')<<10)|(('S'-'@')<<5)|(('L'-'@')<<0)
                                             MNEM    'B','C','C'
04:0BB2  6308              +                 .word   (('B'-'@')<<10)|(('C'-'@')<<5)|(('C'-'@')<<0)
                                             MNEM    'B','C','S'
04:0BB4  7308              +                 .word   (('B'-'@')<<10)|(('C'-'@')<<5)|(('S'-'@')<<0)
                                             MNEM    'B','E','Q'
04:0BB6  B108              +                 .word   (('B'-'@')<<10)|(('E'-'@')<<5)|(('Q'-'@')<<0)
                                             MNEM    'B','I','T'
04:0BB8  3409              +                 .word   (('B'-'@')<<10)|(('I'-'@')<<5)|(('T'-'@')<<0)
                                             MNEM    'B','M','I'
04:0BBA  A909              +                 .word   (('B'-'@')<<10)|(('M'-'@')<<5)|(('I'-'@')<<0)
                                             MNEM    'B','N','E'
04:0BBC  C509              +                 .word   (('B'-'@')<<10)|(('N'-'@')<<5)|(('E'-'@')<<0)
                                             MNEM    'B','P','L'
04:0BBE  0C0A              +                 .word   (('B'-'@')<<10)|(('P'-'@')<<5)|(('L'-'@')<<0)
                                             MNEM    'B','R','A'
04:0BC0  410A              +                 .word   (('B'-'@')<<10)|(('R'-'@')<<5)|(('A'-'@')<<0)
                                             MNEM    'B','R','K'
04:0BC2  4B0A              +                 .word   (('B'-'@')<<10)|(('R'-'@')<<5)|(('K'-'@')<<0)
                                             MNEM    'B','R','L'
04:0BC4  4C0A              +                 .word   (('B'-'@')<<10)|(('R'-'@')<<5)|(('L'-'@')<<0)

Portable 65xx Assembler [19.05]

                                             MNEM    'B','V','C'
04:0BC6  C30A              +                 .word   (('B'-'@')<<10)|(('V'-'@')<<5)|(('C'-'@')<<0)
                                             MNEM    'B','V','S'
04:0BC8  D30A              +                 .word   (('B'-'@')<<10)|(('V'-'@')<<5)|(('S'-'@')<<0)
                                             MNEM    'C','L','C'
04:0BCA  830D              +                 .word   (('C'-'@')<<10)|(('L'-'@')<<5)|(('C'-'@')<<0)
                                             MNEM    'C','L','D'
04:0BCC  840D              +                 .word   (('C'-'@')<<10)|(('L'-'@')<<5)|(('D'-'@')<<0)
                                             MNEM    'C','L','I'
04:0BCE  890D              +                 .word   (('C'-'@')<<10)|(('L'-'@')<<5)|(('I'-'@')<<0)
                                             MNEM    'C','L','V'
04:0BD0  960D              +                 .word   (('C'-'@')<<10)|(('L'-'@')<<5)|(('V'-'@')<<0)
                                             MNEM    'C','M','P'
04:0BD2  B00D              +                 .word   (('C'-'@')<<10)|(('M'-'@')<<5)|(('P'-'@')<<0)
                                             MNEM    'C','O','P'
04:0BD4  F00D              +                 .word   (('C'-'@')<<10)|(('O'-'@')<<5)|(('P'-'@')<<0)
                                             MNEM    'C','P','X'
04:0BD6  180E              +                 .word   (('C'-'@')<<10)|(('P'-'@')<<5)|(('X'-'@')<<0)
                                             MNEM    'C','P','Y'
04:0BD8  190E              +                 .word   (('C'-'@')<<10)|(('P'-'@')<<5)|(('Y'-'@')<<0)
                                             MNEM    'D','E','C'
04:0BDA  A310              +                 .word   (('D'-'@')<<10)|(('E'-'@')<<5)|(('C'-'@')<<0)
                                             MNEM    'D','E','X'
04:0BDC  B810              +                 .word   (('D'-'@')<<10)|(('E'-'@')<<5)|(('X'-'@')<<0)
                                             MNEM    'D','E','Y'
04:0BDE  B910              +                 .word   (('D'-'@')<<10)|(('E'-'@')<<5)|(('Y'-'@')<<0)
                                             MNEM    'E','O','R'
04:0BE0  F215              +                 .word   (('E'-'@')<<10)|(('O'-'@')<<5)|(('R'-'@')<<0)
                                             MNEM    'I','N','C'
04:0BE2  C325              +                 .word   (('I'-'@')<<10)|(('N'-'@')<<5)|(('C'-'@')<<0)
                                             MNEM    'I','N','X'
04:0BE4  D825              +                 .word   (('I'-'@')<<10)|(('N'-'@')<<5)|(('X'-'@')<<0)
                                             MNEM    'I','N','Y'
04:0BE6  D925              +                 .word   (('I'-'@')<<10)|(('N'-'@')<<5)|(('Y'-'@')<<0)
                                             MNEM    'J','M','L'
04:0BE8  AC29              +                 .word   (('J'-'@')<<10)|(('M'-'@')<<5)|(('L'-'@')<<0)
                                             MNEM    'J','M','P'
04:0BEA  B029              +                 .word   (('J'-'@')<<10)|(('M'-'@')<<5)|(('P'-'@')<<0)
                                             MNEM    'J','S','L'
04:0BEC  6C2A              +                 .word   (('J'-'@')<<10)|(('S'-'@')<<5)|(('L'-'@')<<0)
                                             MNEM    'J','S','R'
04:0BEE  722A              +                 .word   (('J'-'@')<<10)|(('S'-'@')<<5)|(('R'-'@')<<0)
                                             MNEM    'L','D','A'
04:0BF0  8130              +                 .word   (('L'-'@')<<10)|(('D'-'@')<<5)|(('A'-'@')<<0)
                                             MNEM    'L','D','X'
04:0BF2  9830              +                 .word   (('L'-'@')<<10)|(('D'-'@')<<5)|(('X'-'@')<<0)
                                             MNEM    'L','D','Y'
04:0BF4  9930              +                 .word   (('L'-'@')<<10)|(('D'-'@')<<5)|(('Y'-'@')<<0)
                                             MNEM    'L','S','R'
04:0BF6  7232              +                 .word   (('L'-'@')<<10)|(('S'-'@')<<5)|(('R'-'@')<<0)
                                             MNEM    'M','V','N'
04:0BF8  CE36              +                 .word   (('M'-'@')<<10)|(('V'-'@')<<5)|(('N'-'@')<<0)
                                             MNEM    'M','V','P'
04:0BFA  D036              +                 .word   (('M'-'@')<<10)|(('V'-'@')<<5)|(('P'-'@')<<0)

Portable 65xx Assembler [19.05]

                                             MNEM    'N','O','P'
04:0BFC  F039              +                 .word   (('N'-'@')<<10)|(('O'-'@')<<5)|(('P'-'@')<<0)
                                             MNEM    'O','R','A'
04:0BFE  413E              +                 .word   (('O'-'@')<<10)|(('R'-'@')<<5)|(('A'-'@')<<0)
                                             MNEM    'P','E','A'
04:0C00  A140              +                 .word   (('P'-'@')<<10)|(('E'-'@')<<5)|(('A'-'@')<<0)
                                             MNEM    'P','E','I'
04:0C02  A940              +                 .word   (('P'-'@')<<10)|(('E'-'@')<<5)|(('I'-'@')<<0)
                                             MNEM    'P','E','R'
04:0C04  B240              +                 .word   (('P'-'@')<<10)|(('E'-'@')<<5)|(('R'-'@')<<0)
                                             MNEM    'P','H','A'
04:0C06  0141              +                 .word   (('P'-'@')<<10)|(('H'-'@')<<5)|(('A'-'@')<<0)
                                             MNEM    'P','H','B'
04:0C08  0241              +                 .word   (('P'-'@')<<10)|(('H'-'@')<<5)|(('B'-'@')<<0)
                                             MNEM    'P','H','D'
04:0C0A  0441              +                 .word   (('P'-'@')<<10)|(('H'-'@')<<5)|(('D'-'@')<<0)
                                             MNEM    'P','H','K'
04:0C0C  0B41              +                 .word   (('P'-'@')<<10)|(('H'-'@')<<5)|(('K'-'@')<<0)
                                             MNEM    'P','H','P'
04:0C0E  1041              +                 .word   (('P'-'@')<<10)|(('H'-'@')<<5)|(('P'-'@')<<0)
                                             MNEM    'P','H','X'
04:0C10  1841              +                 .word   (('P'-'@')<<10)|(('H'-'@')<<5)|(('X'-'@')<<0)
                                             MNEM    'P','H','Y'
04:0C12  1941              +                 .word   (('P'-'@')<<10)|(('H'-'@')<<5)|(('Y'-'@')<<0)
                                             MNEM    'P','L','A'
04:0C14  8141              +                 .word   (('P'-'@')<<10)|(('L'-'@')<<5)|(('A'-'@')<<0)
                                             MNEM    'P','L','B'
04:0C16  8241              +                 .word   (('P'-'@')<<10)|(('L'-'@')<<5)|(('B'-'@')<<0)
                                             MNEM    'P','L','D'
04:0C18  8441              +                 .word   (('P'-'@')<<10)|(('L'-'@')<<5)|(('D'-'@')<<0)
                                             MNEM    'P','L','P'
04:0C1A  9041              +                 .word   (('P'-'@')<<10)|(('L'-'@')<<5)|(('P'-'@')<<0)
                                             MNEM    'P','L','X'
04:0C1C  9841              +                 .word   (('P'-'@')<<10)|(('L'-'@')<<5)|(('X'-'@')<<0)
                                             MNEM    'P','L','Y'
04:0C1E  9941              +                 .word   (('P'-'@')<<10)|(('L'-'@')<<5)|(('Y'-'@')<<0)
                                             MNEM    'R','E','P'
04:0C20  B048              +                 .word   (('R'-'@')<<10)|(('E'-'@')<<5)|(('P'-'@')<<0)
                                             MNEM    'R','O','L'
04:0C22  EC49              +                 .word   (('R'-'@')<<10)|(('O'-'@')<<5)|(('L'-'@')<<0)
                                             MNEM    'R','O','R'
04:0C24  F249              +                 .word   (('R'-'@')<<10)|(('O'-'@')<<5)|(('R'-'@')<<0)
                                             MNEM    'R','T','I'
04:0C26  894A              +                 .word   (('R'-'@')<<10)|(('T'-'@')<<5)|(('I'-'@')<<0)
                                             MNEM    'R','T','L'
04:0C28  8C4A              +                 .word   (('R'-'@')<<10)|(('T'-'@')<<5)|(('L'-'@')<<0)
                                             MNEM    'R','T','S'
04:0C2A  934A              +                 .word   (('R'-'@')<<10)|(('T'-'@')<<5)|(('S'-'@')<<0)
                                             MNEM    'S','B','C'
04:0C2C  434C              +                 .word   (('S'-'@')<<10)|(('B'-'@')<<5)|(('C'-'@')<<0)
                                             MNEM    'S','E','C'
04:0C2E  A34C              +                 .word   (('S'-'@')<<10)|(('E'-'@')<<5)|(('C'-'@')<<0)
                                             MNEM    'S','E','D'
04:0C30  A44C              +                 .word   (('S'-'@')<<10)|(('E'-'@')<<5)|(('D'-'@')<<0)

Portable 65xx Assembler [19.05]

                                             MNEM    'S','E','I'
04:0C32  A94C              +                 .word   (('S'-'@')<<10)|(('E'-'@')<<5)|(('I'-'@')<<0)
                                             MNEM    'S','E','P'
04:0C34  B04C              +                 .word   (('S'-'@')<<10)|(('E'-'@')<<5)|(('P'-'@')<<0)
                                             MNEM    'S','T','A'
04:0C36  814E              +                 .word   (('S'-'@')<<10)|(('T'-'@')<<5)|(('A'-'@')<<0)
                                             MNEM    'S','T','P'
04:0C38  904E              +                 .word   (('S'-'@')<<10)|(('T'-'@')<<5)|(('P'-'@')<<0)
                                             MNEM    'S','T','X'
04:0C3A  984E              +                 .word   (('S'-'@')<<10)|(('T'-'@')<<5)|(('X'-'@')<<0)
                                             MNEM    'S','T','Y'
04:0C3C  994E              +                 .word   (('S'-'@')<<10)|(('T'-'@')<<5)|(('Y'-'@')<<0)
                                             MNEM    'S','T','Z'
04:0C3E  9A4E              +                 .word   (('S'-'@')<<10)|(('T'-'@')<<5)|(('Z'-'@')<<0)
                                             MNEM    'T','A','X'
04:0C40  3850              +                 .word   (('T'-'@')<<10)|(('A'-'@')<<5)|(('X'-'@')<<0)
                                             MNEM    'T','A','Y'
04:0C42  3950              +                 .word   (('T'-'@')<<10)|(('A'-'@')<<5)|(('Y'-'@')<<0)
                                             MNEM    'T','C','D'
04:0C44  6450              +                 .word   (('T'-'@')<<10)|(('C'-'@')<<5)|(('D'-'@')<<0)
                                             MNEM    'T','C','S'
04:0C46  7350              +                 .word   (('T'-'@')<<10)|(('C'-'@')<<5)|(('S'-'@')<<0)
                                             MNEM    'T','D','C'
04:0C48  8350              +                 .word   (('T'-'@')<<10)|(('D'-'@')<<5)|(('C'-'@')<<0)
                                             MNEM    'T','R','B'
04:0C4A  4252              +                 .word   (('T'-'@')<<10)|(('R'-'@')<<5)|(('B'-'@')<<0)
                                             MNEM    'T','S','B'
04:0C4C  6252              +                 .word   (('T'-'@')<<10)|(('S'-'@')<<5)|(('B'-'@')<<0)
                                             MNEM    'T','S','C'
04:0C4E  6352              +                 .word   (('T'-'@')<<10)|(('S'-'@')<<5)|(('C'-'@')<<0)
                                             MNEM    'T','S','X'
04:0C50  7852              +                 .word   (('T'-'@')<<10)|(('S'-'@')<<5)|(('X'-'@')<<0)
                                             MNEM    'T','X','A'
04:0C52  0153              +                 .word   (('T'-'@')<<10)|(('X'-'@')<<5)|(('A'-'@')<<0)
                                             MNEM    'T','X','S'
04:0C54  1353              +                 .word   (('T'-'@')<<10)|(('X'-'@')<<5)|(('S'-'@')<<0)
                                             MNEM    'T','X','Y'
04:0C56  1953              +                 .word   (('T'-'@')<<10)|(('X'-'@')<<5)|(('Y'-'@')<<0)
                                             MNEM    'T','Y','A'
04:0C58  2153              +                 .word   (('T'-'@')<<10)|(('Y'-'@')<<5)|(('A'-'@')<<0)
                                             MNEM    'T','Y','X'
04:0C5A  3853              +                 .word   (('T'-'@')<<10)|(('Y'-'@')<<5)|(('X'-'@')<<0)
                                             MNEM    'W','A','I'
04:0C5C  295C              +                 .word   (('W'-'@')<<10)|(('A'-'@')<<5)|(('I'-'@')<<0)
                                             MNEM    'W','D','M'
04:0C5E  8D5C              +                 .word   (('W'-'@')<<10)|(('D'-'@')<<5)|(('M'-'@')<<0)
                                             MNEM    'X','B','A'
04:0C60  4160              +                 .word   (('X'-'@')<<10)|(('B'-'@')<<5)|(('A'-'@')<<0)
                                             MNEM    'X','C','E'
04:0C62  6560              +                 .word   (('X'-'@')<<10)|(('C'-'@')<<5)|(('E'-'@')<<0)

                                             .end


Portable 65xx Assembler [19.05]

Symbol Table

ADDR_E                           0000EE19  | MD_ABS                           00000000
ADDR_S                           0000EE16  | OP_ADC                           00000000
BEL                              00000007  | WDM_IER_RD                       00000000
BOOT_MESSAGE                     0000F037  | __6501__                         00000000
BRKN                             0000F0D7  | __6502__                         00000000
BS                               00000008  | __65832__                        00000000
BYTES_PER_LINE                   00000064  | __65C02__                        00000000
B_FLAG                           00000010  | __65SC02__                       00000000
CMD_BUF                          0000EE80  | C_FLAG                           00000001
CMD_LEN                          0000EE10  | INT_CLK                          00000001
COPE                             0000F009  | WDM_IER_WR                       00000001
COPN                             0000F00A  | __65816__                        00000001
CR                               0000000D  | INT_U1RX                         00000002
C_FLAG                           00000001  | MD_ACC                           00000002
DEFAULT                          0000EE14  | OP_AND                           00000002
DEL                              0000007F  | WDM_IER_SET                      00000002
D_FLAG                           00000008  | Z_FLAG                           00000002
ESC                              0000001B  | WDM_IER_CLR                      00000003
FLAGS                            0000EE15  | INT_U1TX                         00000004
INT_CLK                          00000001  | I_FLAG                           00000004
INT_U1RX                         00000002  | MD_ABX                           00000004
INT_U1TX                         00000004  | OP_ASL                           00000004
IO_PAGE                          0000EF00  | WDM_IFR_RD                       00000004
IRQBRK                           0000F0CF  | WDM_IFR_WR                       00000005
IRQHandler                       0000F0F4  | MD_ABY                           00000006
IRQN                             0000F0E6  | OP_BCC                           00000006
I_FLAG                           00000004  | WDM_IFR_SET                      00000006
LF                               0000000A  | BEL                              00000007
MD_ABS                           00000000  | WDM_IFR_CLR                      00000007
MD_ABX                           00000004  | BS                               00000008
MD_ABY                           00000006  | D_FLAG                           00000008
MD_ACC                           00000002  | MD_ALG                           00000008
MD_AIN                           0000000C  | OP_BCS                           00000008
MD_AIX                           0000000E  | PIXELS_PER_BYTE                  00000008
MD_ALG                           00000008  | WDM_IFLAGS                       00000008
MD_ALX                           0000000A  | LF                               0000000A
MD_DIN                           00000018  | MD_ALX                           0000000A
MD_DIX                           0000001E  | OP_BEQ                           0000000A
MD_DIY                           00000020  | MD_AIN                           0000000C
MD_DLI                           0000001A  | OP_BIT                           0000000C
MD_DLY                           00000022  | CR                               0000000D
MD_DPG                           00000010  | MD_AIX                           0000000E
MD_DPX                           00000014  | OP_BMI                           0000000E
MD_DPY                           00000016  | B_FLAG                           00000010
MD_IMM                           0000002C  | MD_DPG                           00000010
MD_IMP                           00000024  | OP_BNE                           00000010
MD_IMX                           00000030  | WDM_U1TX                         00000010
MD_INT                           0000002E  | X_FLAG                           00000010
MD_MOV                           0000002A  | WDM_U1RX                         00000011
MD_REL                           00000026  | MD_STK                           00000012
MD_RLG                           00000028  | OP_BPL                           00000012
MD_SKY                           0000001C  | MD_DPX                           00000014

Portable 65xx Assembler [19.05]

MD_STK                           00000012  | OP_BRA                           00000014
MNEMONICS                        00040BAC  | MD_DPY                           00000016
MODES                            00040AAC  | OP_BRK                           00000016
MON_PAGE                         0000EE00  | MD_DIN                           00000018
M_FLAG                           00000020  | OP_BRL                           00000018
Monitor                          00040000  | MD_DLI                           0000001A
Monitor.ADDR                     0004071B  | OP_BVC                           0000001A
Monitor.Absolute                 00040641  | ESC                              0000001B
Monitor.AbsoluteIndirect         00040681  | MD_SKY                           0000001C
Monitor.AbsoluteX                00040654  | OP_BVS                           0000001C
Monitor.AbsoluteXIndirect        0004068E  | MD_DIX                           0000001E
Monitor.AbsoluteY                00040659  | OP_CLC                           0000001E
Monitor.Accumulator              000405CC  | MD_DIY                           00000020
Monitor.AddChar                  0004053E  | M_FLAG                           00000020
Monitor.AddHex                   0004053B  | OP_CLD                           00000020
Monitor.AddHex2                  00040532  | MD_DLY                           00000022
Monitor.AddHexDigit              00040466  | OP_CLI                           00000022
Monitor.BackSpace                00040163  | MD_IMP                           00000024
Monitor.Beep                     00040176  | OP_CLV                           00000024
Monitor.BuildCommand             00040508  | MD_REL                           00000026
Monitor.BumpAddress              000404CE  | OP_CMP                           00000026
Monitor.CloseBracket             000407F5  | MD_RLG                           00000028
Monitor.CompareAddr              000404E0  | OP_COP                           00000028
Monitor.CopyToEnd                000404AC  | MD_MOV                           0000002A
Monitor.CopyToStart              0004049F  | OP_CPX                           0000002A
Monitor.Direct                   0004061A  | MD_IMM                           0000002C
Monitor.DirectIndirect           0004069B  | OP_CPY                           0000002C
Monitor.DirectIndirectLong       000406C5  | MD_INT                           0000002E
Monitor.DirectIndirectLongY      000406D2  | OP_DEC                           0000002E
Monitor.DirectIndirectY          000406B5  | MD_IMX                           00000030
Monitor.DirectX                  00040627  | OP_DEX                           00000030
Monitor.DirectXIndirect          000406A8  | OP_DEY                           00000032
Monitor.DirectY                  00040634  | OP_EOR                           00000034
Monitor.DoREP                    000401F2  | OP_INC                           00000036
Monitor.DoSEP                    000401FC  | OP_INX                           00000038
Monitor.Escape                   000407D7  | OP_INY                           0000003A
Monitor.ExpandMnem               00040729  | OP_JML                           0000003C
Monitor.Flag                     000407F9  | OP_JMP                           0000003E
Monitor.FoundBank                00040424  | OP_JSL                           00000040
Monitor.GetByte                  0004044B  | UART_BUFSIZ                      00000040
Monitor.GetValue                 00040400  | V_FLAG                           00000040
Monitor.Hex                      000407BE  | OP_JSR                           00000042
Monitor.Hex2                     000407B5  | OP_LDA                           00000044
Monitor.Hex4                     000407B0  | OP_LDX                           00000046
Monitor.HexCHi                   000407A0  | OP_LDY                           00000048
Monitor.HexDigit                 00040486  | OP_LSR                           0000004A
Monitor.HexSPHi                  000407AC  | OP_MVN                           0000004C
Monitor.HexXHi                   000407A4  | OP_MVP                           0000004E
Monitor.HexYHi                   000407A8  | OP_NOP                           00000050
Monitor.ImmediateByte            000405FF  | OP_ORA                           00000052
Monitor.ImmediateM               000405D1  | OP_PEA                           00000054
Monitor.ImmediateWord            00040606  | OP_PEI                           00000056
Monitor.ImmediateX               000405D9  | OP_PER                           00000058
Monitor.Implied                  000405E1  | OP_PHA                           0000005A

Portable 65xx Assembler [19.05]

Monitor.InvalidRecord            000403C9  | OP_PHB                           0000005C
Monitor.LONG                     0004065E  | OP_PHD                           0000005E
Monitor.LongX                    0004067C  | OP_PHK                           00000060
Monitor.MODE_SHOW                0004059A  | OP_PHP                           00000062
Monitor.MODE_SIZE                0004073D  | BYTES_PER_LINE                   00000064
Monitor.Mask                     00040801  | OP_PHX                           00000064
Monitor.Move                     000405E2  | OP_PHY                           00000066
Monitor.NewCommand               00040134  | OP_PLA                           00000068
Monitor.NewLine                  00040797  | OP_PLB                           0000006A
Monitor.NextChar                 000404F6  | OP_PLD                           0000006C
Monitor.NextOpcode               000401FE  | OP_PLP                           0000006E
Monitor.OldCommand               00040136  | OP_PLX                           00000070
Monitor.OpcodeSize               00040733  | OP_PLY                           00000072
Monitor.OpenBracket              000407F1  | OP_REP                           00000074
Monitor.Print                    0004078B  | OP_ROL                           00000076
Monitor.Relative                 000406E8  | OP_ROR                           00000078
Monitor.RelativeLong             00040705  | OP_RTI                           0000007A
Monitor.ReturnValue              00040449  | OP_RTL                           0000007C
Monitor.SPACE                    000407ED  | OP_RTS                           0000007E
Monitor.SetByte                  00040344  | DEL                              0000007F
Monitor.SetRegister              000402F7  | N_FLAG                           00000080
Monitor.SetWord                  0004036E  | OP_SBC                           00000080
Monitor.ShortA                   000400A1  | OP_SEC                           00000082
Monitor.ShortX                   000400C7  | OP_SED                           00000084
Monitor.ShortY                   000400ED  | OP_SEI                           00000086
Monitor.ShowAddress              000404B9  | OP_SEP                           00000088
Monitor.ShowBytes                00040542  | OP_STA                           0000008A
Monitor.ShowError                000403F7  | OP_STP                           0000008C
Monitor.ShowRegisters            00040041  | OP_STX                           0000008E
Monitor.ShowSymbolic             0004056B  | OP_STY                           00000090
Monitor.Size1                    0004077F  | OP_STZ                           00000092
Monitor.Size2                    00040782  | OP_TAX                           00000094
Monitor.Size3                    00040785  | OP_TAY                           00000096
Monitor.Size4                    00040788  | OP_TCD                           00000098
Monitor.SkipSpaces               000404EE  | OP_TCS                           0000009A
Monitor.Stack                    0004060D  | OP_TDC                           0000009C
Monitor.StackIndirectY           000406D8  | OP_TRB                           0000009E
Monitor.StrC                     00040815  | OP_TSB                           000000A0
Monitor.StrDBR                   0004082B  | OP_TSC                           000000A2
Monitor.StrDP                    00040821  | OP_TSX                           000000A4
Monitor.StrE                     0004080D  | OP_TXA                           000000A6
Monitor.StrError                 00040831  | OP_TXS                           000000A8
Monitor.StrHelp                  00040860  | OP_TXY                           000000AA
Monitor.StrInvalid               0004084B  | OP_TYA                           000000AC
Monitor.StrP                     00040811  | OP_TYX                           000000AE
Monitor.StrPC                    00040809  | OP_WAI                           000000B0
Monitor.StrSP                    00040826  | OP_WDM                           000000B2
Monitor.StrX                     00040819  | OP_XBA                           000000B4
Monitor.StrY                     0004081D  | OP_XCE                           000000B6
Monitor.TestM                    0004076F  | SVGA_HEIGHT                      00000258
Monitor.TestX                    00040777  | SVGA_WIDTH                       00000320
Monitor.ToHex                    000407C3  | MON_PAGE                         0000EE00
Monitor.ToUpper                  000404FD  | REG_E                            0000EE00
Monitor.UartRx                   000407D2  | REG_P                            0000EE01

Portable 65xx Assembler [19.05]

Monitor.UartTx                   000407CD  | REG_C                            0000EE02
Monitor.X                        0004062A  | REG_X                            0000EE04
Monitor.Y                        00040637  | REG_Y                            0000EE06
N_FLAG                           00000080  | REG_SP                           0000EE08
OPCODES                          000409AC  | REG_DP                           0000EE0A
OP_ADC                           00000000  | REG_PC                           0000EE0C
OP_AND                           00000002  | REG_PBR                          0000EE0E
OP_ASL                           00000004  | REG_DBR                          0000EE0F
OP_BCC                           00000006  | CMD_LEN                          0000EE10
OP_BCS                           00000008  | VALUE                            0000EE11
OP_BEQ                           0000000A  | DEFAULT                          0000EE14
OP_BIT                           0000000C  | FLAGS                            0000EE15
OP_BMI                           0000000E  | ADDR_S                           0000EE16
OP_BNE                           00000010  | ADDR_E                           0000EE19
OP_BPL                           00000012  | CMD_BUF                          0000EE80
OP_BRA                           00000014  | IO_PAGE                          0000EF00
OP_BRK                           00000016  | TX_HEAD                          0000EF00
OP_BRL                           00000018  | TX_TAIL                          0000EF01
OP_BVC                           0000001A  | RX_HEAD                          0000EF02
OP_BVS                           0000001C  | RX_TAIL                          0000EF03
OP_CLC                           0000001E  | TICK                             0000EF04
OP_CLD                           00000020  | TX_DATA                          0000EF08
OP_CLI                           00000022  | RX_DATA                          0000EF48
OP_CLV                           00000024  | COPE                             0000F009
OP_CMP                           00000026  | COPN                             0000F00A
OP_COP                           00000028  | RESET                            0000F00B
OP_CPX                           0000002A  | BOOT_MESSAGE                     0000F037
OP_CPY                           0000002C  | Uart1Tx                          0000F06F
OP_DEC                           0000002E  | Uart1Rx                          0000F09D
OP_DEX                           00000030  | Uart1RxCount                     0000F0BD
OP_DEY                           00000032  | IRQBRK                           0000F0CF
OP_EOR                           00000034  | BRKN                             0000F0D7
OP_INC                           00000036  | IRQN                             0000F0E6
OP_INX                           00000038  | IRQHandler                       0000F0F4
OP_INY                           0000003A  | UnusedVector                     0000F14D
OP_JML                           0000003C  | VLINES                           00010000
OP_JMP                           0000003E  | VDATA                            000104B0
OP_JSL                           00000040  | VEND                             0001EF10
OP_JSR                           00000042  | Monitor                          00040000
OP_LDA                           00000044  | Monitor.ShowRegisters            00040041
OP_LDX                           00000046  | Monitor.ShortA                   000400A1
OP_LDY                           00000048  | Monitor.ShortX                   000400C7
OP_LSR                           0000004A  | Monitor.ShortY                   000400ED
OP_MVN                           0000004C  | Monitor.NewCommand               00040134
OP_MVP                           0000004E  | Monitor.OldCommand               00040136
OP_NOP                           00000050  | Monitor.BackSpace                00040163
OP_ORA                           00000052  | Monitor.Beep                     00040176
OP_PEA                           00000054  | Monitor.DoREP                    000401F2
OP_PEI                           00000056  | Monitor.DoSEP                    000401FC
OP_PER                           00000058  | Monitor.NextOpcode               000401FE
OP_PHA                           0000005A  | Monitor.SetRegister              000402F7
OP_PHB                           0000005C  | Monitor.SetByte                  00040344
OP_PHD                           0000005E  | Monitor.SetWord                  0004036E
OP_PHK                           00000060  | Monitor.InvalidRecord            000403C9

Portable 65xx Assembler [19.05]

OP_PHP                           00000062  | Monitor.ShowError                000403F7
OP_PHX                           00000064  | Monitor.GetValue                 00040400
OP_PHY                           00000066  | Monitor.FoundBank                00040424
OP_PLA                           00000068  | Monitor.ReturnValue              00040449
OP_PLB                           0000006A  | Monitor.GetByte                  0004044B
OP_PLD                           0000006C  | Monitor.AddHexDigit              00040466
OP_PLP                           0000006E  | Monitor.HexDigit                 00040486
OP_PLX                           00000070  | Monitor.CopyToStart              0004049F
OP_PLY                           00000072  | Monitor.CopyToEnd                000404AC
OP_REP                           00000074  | Monitor.ShowAddress              000404B9
OP_ROL                           00000076  | Monitor.BumpAddress              000404CE
OP_ROR                           00000078  | Monitor.CompareAddr              000404E0
OP_RTI                           0000007A  | Monitor.SkipSpaces               000404EE
OP_RTL                           0000007C  | Monitor.NextChar                 000404F6
OP_RTS                           0000007E  | Monitor.ToUpper                  000404FD
OP_SBC                           00000080  | Monitor.BuildCommand             00040508
OP_SEC                           00000082  | Monitor.AddHex2                  00040532
OP_SED                           00000084  | Monitor.AddHex                   0004053B
OP_SEI                           00000086  | Monitor.AddChar                  0004053E
OP_SEP                           00000088  | Monitor.ShowBytes                00040542
OP_STA                           0000008A  | Monitor.ShowSymbolic             0004056B
OP_STP                           0000008C  | Monitor.MODE_SHOW                0004059A
OP_STX                           0000008E  | Monitor.Accumulator              000405CC
OP_STY                           00000090  | Monitor.ImmediateM               000405D1
OP_STZ                           00000092  | Monitor.ImmediateX               000405D9
OP_TAX                           00000094  | Monitor.Implied                  000405E1
OP_TAY                           00000096  | Monitor.Move                     000405E2
OP_TCD                           00000098  | Monitor.ImmediateByte            000405FF
OP_TCS                           0000009A  | Monitor.ImmediateWord            00040606
OP_TDC                           0000009C  | Monitor.Stack                    0004060D
OP_TRB                           0000009E  | Monitor.Direct                   0004061A
OP_TSB                           000000A0  | Monitor.DirectX                  00040627
OP_TSC                           000000A2  | Monitor.X                        0004062A
OP_TSX                           000000A4  | Monitor.DirectY                  00040634
OP_TXA                           000000A6  | Monitor.Y                        00040637
OP_TXS                           000000A8  | Monitor.Absolute                 00040641
OP_TXY                           000000AA  | Monitor.AbsoluteX                00040654
OP_TYA                           000000AC  | Monitor.AbsoluteY                00040659
OP_TYX                           000000AE  | Monitor.LONG                     0004065E
OP_WAI                           000000B0  | Monitor.LongX                    0004067C
OP_WDM                           000000B2  | Monitor.AbsoluteIndirect         00040681
OP_XBA                           000000B4  | Monitor.AbsoluteXIndirect        0004068E
OP_XCE                           000000B6  | Monitor.DirectIndirect           0004069B
PIXELS_PER_BYTE                  00000008  | Monitor.DirectXIndirect          000406A8
REG_C                            0000EE02  | Monitor.DirectIndirectY          000406B5
REG_DBR                          0000EE0F  | Monitor.DirectIndirectLong       000406C5
REG_DP                           0000EE0A  | Monitor.DirectIndirectLongY      000406D2
REG_E                            0000EE00  | Monitor.StackIndirectY           000406D8
REG_P                            0000EE01  | Monitor.Relative                 000406E8
REG_PBR                          0000EE0E  | Monitor.RelativeLong             00040705
REG_PC                           0000EE0C  | Monitor.ADDR                     0004071B
REG_SP                           0000EE08  | Monitor.ExpandMnem               00040729
REG_X                            0000EE04  | Monitor.OpcodeSize               00040733
REG_Y                            0000EE06  | Monitor.MODE_SIZE                0004073D

Portable 65xx Assembler [19.05]

RESET                            0000F00B  | Monitor.TestM                    0004076F
RX_DATA                          0000EF48  | Monitor.TestX                    00040777
RX_HEAD                          0000EF02  | Monitor.Size1                    0004077F
RX_TAIL                          0000EF03  | Monitor.Size2                    00040782
SVGA_HEIGHT                      00000258  | Monitor.Size3                    00040785
SVGA_WIDTH                       00000320  | Monitor.Size4                    00040788
TICK                             0000EF04  | Monitor.Print                    0004078B
TX_DATA                          0000EF08  | Monitor.NewLine                  00040797
TX_HEAD                          0000EF00  | Monitor.HexCHi                   000407A0
TX_TAIL                          0000EF01  | Monitor.HexXHi                   000407A4
UART_BUFSIZ                      00000040  | Monitor.HexYHi                   000407A8
Uart1Rx                          0000F09D  | Monitor.HexSPHi                  000407AC
Uart1RxCount                     0000F0BD  | Monitor.Hex4                     000407B0
Uart1Tx                          0000F06F  | Monitor.Hex2                     000407B5
UnusedVector                     0000F14D  | Monitor.Hex                      000407BE
VALUE                            0000EE11  | Monitor.ToHex                    000407C3
VDATA                            000104B0  | Monitor.UartTx                   000407CD
VEND                             0001EF10  | Monitor.UartRx                   000407D2
VLINES                           00010000  | Monitor.Escape                   000407D7
V_FLAG                           00000040  | Monitor.SPACE                    000407ED
WDM_IER_CLR                      00000003  | Monitor.OpenBracket              000407F1
WDM_IER_RD                       00000000  | Monitor.CloseBracket             000407F5
WDM_IER_SET                      00000002  | Monitor.Flag                     000407F9
WDM_IER_WR                       00000001  | Monitor.Mask                     00040801
WDM_IFLAGS                       00000008  | Monitor.StrPC                    00040809
WDM_IFR_CLR                      00000007  | Monitor.StrE                     0004080D
WDM_IFR_RD                       00000004  | Monitor.StrP                     00040811
WDM_IFR_SET                      00000006  | Monitor.StrC                     00040815
WDM_IFR_WR                       00000005  | Monitor.StrX                     00040819
WDM_U1RX                         00000011  | Monitor.StrY                     0004081D
WDM_U1TX                         00000010  | Monitor.StrDP                    00040821
X_FLAG                           00000010  | Monitor.StrSP                    00040826
Z_FLAG                           00000002  | Monitor.StrDBR                   0004082B
__6501__                         00000000  | Monitor.StrError                 00040831
__6502__                         00000000  | Monitor.StrInvalid               0004084B
__65816__                        00000001  | Monitor.StrHelp                  00040860
__65832__                        00000000  | OPCODES                          000409AC
__65C02__                        00000000  | MODES                            00040AAC
__65SC02__                       00000000  | MNEMONICS                        00040BAC
